// THIS FILE IS AUTOMATICALLY GENERATED BY `generateContractInterfaces.ts`. DO NOT EDIT BY HAND'

export type Int256<TLargeInteger> = TLargeInteger
export type Int248<TLargeInteger> = TLargeInteger
export type Int240<TLargeInteger> = TLargeInteger
export type Int232<TLargeInteger> = TLargeInteger
export type Int224<TLargeInteger> = TLargeInteger
export type Int216<TLargeInteger> = TLargeInteger
export type Int208<TLargeInteger> = TLargeInteger
export type Int200<TLargeInteger> = TLargeInteger
export type Int192<TLargeInteger> = TLargeInteger
export type Int184<TLargeInteger> = TLargeInteger
export type Int176<TLargeInteger> = TLargeInteger
export type Int168<TLargeInteger> = TLargeInteger
export type Int160<TLargeInteger> = TLargeInteger
export type Int152<TLargeInteger> = TLargeInteger
export type Int144<TLargeInteger> = TLargeInteger
export type Int136<TLargeInteger> = TLargeInteger
export type Int128<TLargeInteger> = TLargeInteger
export type Int120<TLargeInteger> = TLargeInteger
export type Int112<TLargeInteger> = TLargeInteger
export type Int104<TLargeInteger> = TLargeInteger
export type Int96<TLargeInteger> = TLargeInteger
export type Int88<TLargeInteger> = TLargeInteger
export type Int80<TLargeInteger> = TLargeInteger
export type Int72<TLargeInteger> = TLargeInteger
export type Int64<TLargeInteger> = TLargeInteger
export type Int56<TLargeInteger> = TLargeInteger
export type Int48<TLargeInteger> = TLargeInteger
export type Int40<TLargeInteger> = TLargeInteger
export type Int32 = number
export type Int24 = number
export type Int16 = number
export type Int8 = number
export type UInt256<TLargeInteger> = TLargeInteger
export type UInt248<TLargeInteger> = TLargeInteger
export type UInt240<TLargeInteger> = TLargeInteger
export type UInt232<TLargeInteger> = TLargeInteger
export type UInt224<TLargeInteger> = TLargeInteger
export type UInt216<TLargeInteger> = TLargeInteger
export type UInt208<TLargeInteger> = TLargeInteger
export type UInt200<TLargeInteger> = TLargeInteger
export type UInt192<TLargeInteger> = TLargeInteger
export type UInt184<TLargeInteger> = TLargeInteger
export type UInt176<TLargeInteger> = TLargeInteger
export type UInt168<TLargeInteger> = TLargeInteger
export type UInt160<TLargeInteger> = TLargeInteger
export type UInt152<TLargeInteger> = TLargeInteger
export type UInt144<TLargeInteger> = TLargeInteger
export type UInt136<TLargeInteger> = TLargeInteger
export type UInt128<TLargeInteger> = TLargeInteger
export type UInt120<TLargeInteger> = TLargeInteger
export type UInt112<TLargeInteger> = TLargeInteger
export type UInt104<TLargeInteger> = TLargeInteger
export type UInt96<TLargeInteger> = TLargeInteger
export type UInt88<TLargeInteger> = TLargeInteger
export type UInt80<TLargeInteger> = TLargeInteger
export type UInt72<TLargeInteger> = TLargeInteger
export type UInt64<TLargeInteger> = TLargeInteger
export type UInt56<TLargeInteger> = TLargeInteger
export type UInt48<TLargeInteger> = TLargeInteger
export type UInt40<TLargeInteger> = TLargeInteger
export type UInt32 = number
export type UInt24 = number
export type UInt16 = number
export type UInt8 = number
abstract class ByteArray<T extends ByteArray<T>> extends Uint8Array {
    static get [Symbol.species]() {
        return Uint8Array
    }

    from(this: T, bytes: Uint8Array, pad?: 'left' | 'right'): T

    from(this: T, hex: string): T

    from(this: T, data: Uint8Array | string, pad?: 'left' | 'right'): T {
        if (typeof data === 'string') {
            const match = new RegExp(`^(?:0x)?([a-fA-F0-9]{${this.length * 2}})$`).exec(data);
            if (match === null) throw new Error(`Can only create a ByteArray of size ${this.length} from a hex encoded string of length ${this.length} starting with an optional 0x`);
            const normalized = match[1];
            for (let i = 0; i < this.length; ++i) {
                this[i] = Number.parseInt(`${normalized[i * 2]}${normalized[i * 2 + 1]}`, 16)
            }
            return this
        } else if (data instanceof Uint8Array) {
            if (data.length <= this.length) {
                this.set(data, (pad === 'left') ? this.length - data.length : 0);
                return this
            } else {
                throw new Error(`Source bytes are longer (${data.length}) than destination bytes ${this.length}\n${data}`)
            }
        } else throw new Error(`Unexpected paramater type ${typeof data}\n${data}`)
    }

    toString = () => this.reduce((result: string, byte: number) => result + ('0' + byte.toString(16)).slice(-2), '');

    to0xString = () => `0x${this.toString()}`;

    equals = (other?: Uint8Array | null): boolean => {
        if (other === undefined || other === null) return false;
        if (this.length !== other.length) return false;
        for (let i = 0; i < this.length; ++i) {
            if (this[i] !== other[i]) return false
        }
        return true
    }
}

export class Bytes extends ByteArray<Bytes> {
    Bytes: unknown
}

export class Bytes32 extends ByteArray<Bytes32> {
    Bytes32: unknown;

    constructor() {
        super(32)
    };
}

export class Bytes31 extends ByteArray<Bytes31> {
    Bytes31: unknown;

    constructor() {
        super(31)
    };
}

export class Bytes30 extends ByteArray<Bytes30> {
    Bytes30: unknown;

    constructor() {
        super(30)
    };
}

export class Bytes29 extends ByteArray<Bytes29> {
    Bytes29: unknown;

    constructor() {
        super(29)
    };
}

export class Bytes28 extends ByteArray<Bytes28> {
    Bytes28: unknown;

    constructor() {
        super(28)
    };
}

export class Bytes27 extends ByteArray<Bytes27> {
    Bytes27: unknown;

    constructor() {
        super(27)
    };
}

export class Bytes26 extends ByteArray<Bytes26> {
    Bytes26: unknown;

    constructor() {
        super(26)
    };
}

export class Bytes25 extends ByteArray<Bytes25> {
    Bytes25: unknown;

    constructor() {
        super(25)
    };
}

export class Bytes24 extends ByteArray<Bytes24> {
    Bytes24: unknown;

    constructor() {
        super(24)
    };
}

export class Bytes23 extends ByteArray<Bytes23> {
    Bytes23: unknown;

    constructor() {
        super(23)
    };
}

export class Bytes22 extends ByteArray<Bytes22> {
    Bytes22: unknown;

    constructor() {
        super(22)
    };
}

export class Bytes21 extends ByteArray<Bytes21> {
    Bytes21: unknown;

    constructor() {
        super(21)
    };
}

export class Bytes20 extends ByteArray<Bytes20> {
    Bytes20: unknown;

    constructor() {
        super(20)
    };
}

export class Bytes19 extends ByteArray<Bytes19> {
    Bytes19: unknown;

    constructor() {
        super(19)
    };
}

export class Bytes18 extends ByteArray<Bytes18> {
    Bytes18: unknown;

    constructor() {
        super(18)
    };
}

export class Bytes17 extends ByteArray<Bytes17> {
    Bytes17: unknown;

    constructor() {
        super(17)
    };
}

export class Bytes16 extends ByteArray<Bytes16> {
    Bytes16: unknown;

    constructor() {
        super(16)
    };
}

export class Bytes15 extends ByteArray<Bytes15> {
    Bytes15: unknown;

    constructor() {
        super(15)
    };
}

export class Bytes14 extends ByteArray<Bytes14> {
    Bytes14: unknown;

    constructor() {
        super(14)
    };
}

export class Bytes13 extends ByteArray<Bytes13> {
    Bytes13: unknown;

    constructor() {
        super(13)
    };
}

export class Bytes12 extends ByteArray<Bytes12> {
    Bytes12: unknown;

    constructor() {
        super(12)
    };
}

export class Bytes11 extends ByteArray<Bytes11> {
    Bytes11: unknown;

    constructor() {
        super(11)
    };
}

export class Bytes10 extends ByteArray<Bytes10> {
    Bytes10: unknown;

    constructor() {
        super(10)
    };
}

export class Bytes9 extends ByteArray<Bytes9> {
    Bytes9: unknown;

    constructor() {
        super(9)
    };
}

export class Bytes8 extends ByteArray<Bytes8> {
    Bytes8: unknown;

    constructor() {
        super(8)
    };
}

export class Bytes7 extends ByteArray<Bytes7> {
    Bytes7: unknown;

    constructor() {
        super(7)
    };
}

export class Bytes6 extends ByteArray<Bytes6> {
    Bytes6: unknown;

    constructor() {
        super(6)
    };
}

export class Bytes5 extends ByteArray<Bytes5> {
    Bytes5: unknown;

    constructor() {
        super(5)
    };
}

export class Bytes4 extends ByteArray<Bytes4> {
    Bytes4: unknown;

    constructor() {
        super(4)
    };
}

export class Bytes3 extends ByteArray<Bytes3> {
    Bytes3: unknown;

    constructor() {
        super(3)
    };
}

export class Bytes2 extends ByteArray<Bytes2> {
    Bytes2: unknown;

    constructor() {
        super(2)
    };
}

export class Bytes1 extends ByteArray<Bytes1> {
    Bytes1: unknown;

    constructor() {
        super(1)
    };
}

export class Address extends ByteArray<Address> {
    Address: unknown;

    constructor() {
        super(20)
    };
}

export class SignatureHash extends ByteArray<SignatureHash> {
    SignatureHash: unknown;

    constructor() {
        super(4)
    };
}

export type LargeSignedNumberLike<TLargeInteger> =
    Int256<TLargeInteger>
    | Int248<TLargeInteger>
    | Int240<TLargeInteger>
    | Int232<TLargeInteger>
    | Int224<TLargeInteger>
    | Int216<TLargeInteger>
    | Int208<TLargeInteger>
    | Int200<TLargeInteger>
    | Int192<TLargeInteger>
    | Int184<TLargeInteger>
    | Int176<TLargeInteger>
    | Int168<TLargeInteger>
    | Int160<TLargeInteger>
    | Int152<TLargeInteger>
    | Int144<TLargeInteger>
    | Int136<TLargeInteger>
    | Int128<TLargeInteger>
    | Int120<TLargeInteger>
    | Int112<TLargeInteger>
    | Int104<TLargeInteger>
    | Int96<TLargeInteger>
    | Int88<TLargeInteger>
    | Int80<TLargeInteger>
    | Int72<TLargeInteger>
    | Int64<TLargeInteger>
    | Int56<TLargeInteger>
    | Int48<TLargeInteger>
    | Int40<TLargeInteger>
export type LargeUnsignedNumberLike<TLargeInteger> =
    UInt256<TLargeInteger>
    | UInt248<TLargeInteger>
    | UInt240<TLargeInteger>
    | UInt232<TLargeInteger>
    | UInt224<TLargeInteger>
    | UInt216<TLargeInteger>
    | UInt208<TLargeInteger>
    | UInt200<TLargeInteger>
    | UInt192<TLargeInteger>
    | UInt184<TLargeInteger>
    | UInt176<TLargeInteger>
    | UInt168<TLargeInteger>
    | UInt160<TLargeInteger>
    | UInt152<TLargeInteger>
    | UInt144<TLargeInteger>
    | UInt136<TLargeInteger>
    | UInt128<TLargeInteger>
    | UInt120<TLargeInteger>
    | UInt112<TLargeInteger>
    | UInt104<TLargeInteger>
    | UInt96<TLargeInteger>
    | UInt88<TLargeInteger>
    | UInt80<TLargeInteger>
    | UInt72<TLargeInteger>
    | UInt64<TLargeInteger>
    | UInt56<TLargeInteger>
    | UInt48<TLargeInteger>
    | UInt40<TLargeInteger>
export type LargeNumberLike<TLargeInteger> =
    LargeSignedNumberLike<TLargeInteger>
    | LargeUnsignedNumberLike<TLargeInteger>
export type SmallSignedNumberLike = Int32 | Int24 | Int16 | Int8
export type SmallUnsignedNumberLike = UInt32 | UInt24 | UInt16 | UInt8
export type SmallNumberLike = SmallSignedNumberLike | SmallUnsignedNumberLike
export type NumberLike<TLargeInteger> = LargeNumberLike<TLargeInteger> | SmallNumberLike
export type FixedBytesLike =
    Bytes32
    | Bytes31
    | Bytes30
    | Bytes29
    | Bytes28
    | Bytes27
    | Bytes26
    | Bytes25
    | Bytes24
    | Bytes23
    | Bytes22
    | Bytes21
    | Bytes20
    | Bytes19
    | Bytes18
    | Bytes17
    | Bytes16
    | Bytes15
    | Bytes14
    | Bytes13
    | Bytes12
    | Bytes11
    | Bytes10
    | Bytes9
    | Bytes8
    | Bytes7
    | Bytes6
    | Bytes5
    | Bytes4
    | Bytes3
    | Bytes2
    | Bytes1
export type BytesLike = Bytes | FixedBytesLike | Address | SignatureHash
export type EncodablePrimitive<TLargeInteger> = NumberLike<TLargeInteger> | BytesLike | string | boolean
export type Encodable<TLargeInteger> =
    EncodablePrimitive<TLargeInteger>
    | EncodableTuple<TLargeInteger>
    | EncodableArray<TLargeInteger>
export interface EncodableTuple<TLargeInteger> {
    [x: string]: Encodable<TLargeInteger>
}

export interface EncodableArray<TLargeInteger> extends Array<Encodable<TLargeInteger>> {
}

export interface Transaction<TLargeInteger> {
    to: Address
    data: Bytes
    value?: UInt256<TLargeInteger>
}

export interface TransactionReceipt {
    success: boolean
    events: Array<EncodedEvent>
}

export interface EncodedEvent {
    topics: Array<Bytes32>
    data: Bytes
}

export interface DecodedEvent<TLargeInteger> {
	name: string
    parameters: EncodableTuple<TLargeInteger>
}

export interface EventDescription {
	name: string
	signature: string
    parameters: Array<EventParameterDescription>
}

export interface EventParameterDescription extends ParameterDescription {
    indexed: boolean
}

export interface ParameterDescription {
    name: string
    type: string
    components?: Array<ParameterDescription>
}


export const eventDescriptions: { [signatureHash: string]: EventDescription } = {
    'b2e65de73007eef46316e4f18ab1f301b4d0e31aa56733387b469612f90894df': {
        "name": "MarketCreated",
        "signature": "MarketCreated(bytes32,string,string,address,address,address,bytes32[],uint256,int256,int256,uint8)",
        "parameters": [{ "indexed": true, "name": "topic", "type": "bytes32" }, {
            "indexed": false,
            "name": "description",
            "type": "string"
        }, { "indexed": false, "name": "extraInfo", "type": "string" }, {
            "indexed": true,
            "name": "universe",
            "type": "address"
        }, { "indexed": false, "name": "market", "type": "address" }, {
            "indexed": true,
            "name": "marketCreator",
            "type": "address"
        }, { "indexed": false, "name": "outcomes", "type": "bytes32[]" }, {
            "indexed": false,
            "name": "marketCreationFee",
            "type": "uint256"
        }, { "indexed": false, "name": "minPrice", "type": "int256" }, {
            "indexed": false,
            "name": "maxPrice",
            "type": "int256"
        }, { "indexed": false, "name": "marketType", "type": "uint8" }]
    },
    'dca091705672332bdafb39197c1ecb094e5ab5c43ef002febe4f63f635b06cc3': {
        "name": "InitialReportSubmitted",
        "signature": "InitialReportSubmitted(address,address,address,uint256,bool,uint256[],string)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "reporter",
            "type": "address"
        }, { "indexed": true, "name": "market", "type": "address" }, {
            "indexed": false,
            "name": "amountStaked",
            "type": "uint256"
        }, { "indexed": false, "name": "isDesignatedReporter", "type": "bool" }, {
            "indexed": false,
            "name": "payoutNumerators",
            "type": "uint256[]"
        }, { "indexed": false, "name": "description", "type": "string" }]
    },
    'b7aa73f66ac8208155a172e486b3fba4670ce50730dd52b0a8550319d988a759': {
        "name": "DisputeCrowdsourcerCreated",
        "signature": "DisputeCrowdsourcerCreated(address,address,address,uint256[],uint256)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "market",
            "type": "address"
        }, { "indexed": false, "name": "disputeCrowdsourcer", "type": "address" }, {
            "indexed": false,
            "name": "payoutNumerators",
            "type": "uint256[]"
        }, { "indexed": false, "name": "size", "type": "uint256" }]
    },
    '1ba97c2894f2b4eb21d849bdb2c4b2007b3562407a13d5581e8cc603ccfc70aa': {
        "name": "DisputeCrowdsourcerContribution",
        "signature": "DisputeCrowdsourcerContribution(address,address,address,address,uint256,string)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "reporter",
            "type": "address"
        }, { "indexed": true, "name": "market", "type": "address" }, {
            "indexed": false,
            "name": "disputeCrowdsourcer",
            "type": "address"
        }, { "indexed": false, "name": "amountStaked", "type": "uint256" }, {
            "indexed": false,
            "name": "description",
            "type": "string"
        }]
    },
    'ec05f094139821aeb3220a0837f5d14eb02aa619179aadf3b316ed95b3648abb': {
        "name": "DisputeCrowdsourcerCompleted",
        "signature": "DisputeCrowdsourcerCompleted(address,address,address)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "market",
            "type": "address"
        }, { "indexed": false, "name": "disputeCrowdsourcer", "type": "address" }]
    },
    'baa0044b60a1c2508a8f206d834572055eb39930f1fe1b2af7c24cdbd58c3bc2': {
        "name": "InitialReporterRedeemed",
        "signature": "InitialReporterRedeemed(address,address,address,uint256,uint256,uint256[])",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "reporter",
            "type": "address"
        }, { "indexed": true, "name": "market", "type": "address" }, {
            "indexed": false,
            "name": "amountRedeemed",
            "type": "uint256"
        }, { "indexed": false, "name": "repReceived", "type": "uint256" }, {
            "indexed": false,
            "name": "payoutNumerators",
            "type": "uint256[]"
        }]
    },
    '4cfd61248791a6340d00c2ad47b105da88969d77f53230418f614e35cd7cc496': {
        "name": "DisputeCrowdsourcerRedeemed",
        "signature": "DisputeCrowdsourcerRedeemed(address,address,address,address,uint256,uint256,uint256[])",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "reporter",
            "type": "address"
        }, { "indexed": true, "name": "market", "type": "address" }, {
            "indexed": false,
            "name": "disputeCrowdsourcer",
            "type": "address"
        }, { "indexed": false, "name": "amountRedeemed", "type": "uint256" }, {
            "indexed": false,
            "name": "repReceived",
            "type": "uint256"
        }, { "indexed": false, "name": "payoutNumerators", "type": "uint256[]" }]
    },
    'b20adf682c8f82b94a135452f54ac4483c9ee8c9b2324e946120696ab1d034b4': {
        "name": "ReportingParticipantDisavowed",
        "signature": "ReportingParticipantDisavowed(address,address,address)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "market",
            "type": "address"
        }, { "indexed": false, "name": "reportingParticipant", "type": "address" }]
    },
    '3b4f3db017516414df2695e5b0052661779d7163a6cd4368fd74313be73fa0b8': {
        "name": "MarketParticipantsDisavowed",
        "signature": "MarketParticipantsDisavowed(address,address)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "market",
            "type": "address"
        }]
    },
    '014ce4e12965529d7d31e11411d7a23b1778d448ab763ffc4d55830cbb4919d7': {
        "name": "MarketFinalized",
        "signature": "MarketFinalized(address,address)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "market",
            "type": "address"
        }]
    },
    'c3cf07f8fa0fafc25a9dd0bad2cd6b961c55dad41b42c8ef8f931bc40e41e08c': {
        "name": "MarketMigrated",
        "signature": "MarketMigrated(address,address,address)",
        "parameters": [{ "indexed": true, "name": "market", "type": "address" }, {
            "indexed": true,
            "name": "originalUniverse",
            "type": "address"
        }, { "indexed": true, "name": "newUniverse", "type": "address" }]
    },
    'd4d990bbdf9b9a4383a394341465060ccb75513432ceee3d5fcd8788ab1a507f': {
        "name": "UniverseForked",
        "signature": "UniverseForked(address)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }]
    },
    '130b934c782f0f2a31fd2c8885061de3984dac97cbbbf0333b3ad30efff892e5': {
        "name": "UniverseCreated",
        "signature": "UniverseCreated(address,address,uint256[])",
        "parameters": [{ "indexed": true, "name": "parentUniverse", "type": "address" }, {
            "indexed": true,
            "name": "childUniverse",
            "type": "address"
        }, { "indexed": false, "name": "payoutNumerators", "type": "uint256[]" }]
    },
    '513d029ff62330c16d8d4b36b28fab53f09d10bb51b56fe121ab710ca2d1af80': {
        "name": "OrderCanceled",
        "signature": "OrderCanceled(address,address,address,bytes32,uint8,uint256,uint256)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "shareToken",
            "type": "address"
        }, { "indexed": true, "name": "sender", "type": "address" }, {
            "indexed": false,
            "name": "orderId",
            "type": "bytes32"
        }, { "indexed": false, "name": "orderType", "type": "uint8" }, {
            "indexed": false,
            "name": "tokenRefund",
            "type": "uint256"
        }, { "indexed": false, "name": "sharesRefund", "type": "uint256" }]
    },
    '32d554e498d0c7f2a5c7fd8b6b234bfc4e1dfb5290466d998af09a813db32f31': {
        "name": "OrderCreated",
        "signature": "OrderCreated(uint8,uint256,uint256,address,uint256,uint256,bytes32,bytes32,address,address)",
        "parameters": [{ "indexed": false, "name": "orderType", "type": "uint8" }, {
            "indexed": false,
            "name": "amount",
            "type": "uint256"
        }, { "indexed": false, "name": "price", "type": "uint256" }, {
            "indexed": true,
            "name": "creator",
            "type": "address"
        }, { "indexed": false, "name": "moneyEscrowed", "type": "uint256" }, {
            "indexed": false,
            "name": "sharesEscrowed",
            "type": "uint256"
        }, { "indexed": false, "name": "tradeGroupId", "type": "bytes32" }, {
            "indexed": false,
            "name": "orderId",
            "type": "bytes32"
        }, { "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "shareToken",
            "type": "address"
        }]
    },
    'abb970462c1f0de9e237d127ad47c01c4e69caa179fd850d076ae9bfc529176e': {
        "name": "OrderFilled",
        "signature": "OrderFilled(address,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bytes32)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "shareToken",
            "type": "address"
        }, { "indexed": false, "name": "filler", "type": "address" }, {
            "indexed": false,
            "name": "orderId",
            "type": "bytes32"
        }, { "indexed": false, "name": "numCreatorShares", "type": "uint256" }, {
            "indexed": false,
            "name": "numCreatorTokens",
            "type": "uint256"
        }, { "indexed": false, "name": "numFillerShares", "type": "uint256" }, {
            "indexed": false,
            "name": "numFillerTokens",
            "type": "uint256"
        }, { "indexed": false, "name": "marketCreatorFees", "type": "uint256" }, {
            "indexed": false,
            "name": "reporterFees",
            "type": "uint256"
        }, { "indexed": false, "name": "amountFilled", "type": "uint256" }, {
            "indexed": false,
            "name": "tradeGroupId",
            "type": "bytes32"
        }]
    },
    '349ab20f76ba930a00da1936627d07400af6bb7cd2e2b4c68bcab93ca8aff418': {
        "name": "CompleteSetsPurchased",
        "signature": "CompleteSetsPurchased(address,address,address,uint256)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "market",
            "type": "address"
        }, { "indexed": true, "name": "account", "type": "address" }, {
            "indexed": false,
            "name": "numCompleteSets",
            "type": "uint256"
        }]
    },
    '68166bb2a567c21899b00209f52c286bf00ac613acc9f183da791ac5f5f47051': {
        "name": "CompleteSetsSold",
        "signature": "CompleteSetsSold(address,address,address,uint256)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "market",
            "type": "address"
        }, { "indexed": true, "name": "account", "type": "address" }, {
            "indexed": false,
            "name": "numCompleteSets",
            "type": "uint256"
        }]
    },
    'a7e9373569caad2b7871ecb4d498619fc1c42840a6c0dbeb8dff20b131721e50': {
        "name": "TradingProceedsClaimed",
        "signature": "TradingProceedsClaimed(address,address,address,address,uint256,uint256,uint256)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "shareToken",
            "type": "address"
        }, { "indexed": true, "name": "sender", "type": "address" }, {
            "indexed": false,
            "name": "market",
            "type": "address"
        }, { "indexed": false, "name": "numShares", "type": "uint256" }, {
            "indexed": false,
            "name": "numPayoutTokens",
            "type": "uint256"
        }, { "indexed": false, "name": "finalTokenBalance", "type": "uint256" }]
    },
    '3c67396e9c55d2fc8ad68875fc5beca1d96ad2a2f23b210ccc1d986551ab6fdf': {
        "name": "TokensTransferred",
        "signature": "TokensTransferred(address,address,address,address,uint256,uint8,address)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "token",
            "type": "address"
        }, { "indexed": true, "name": "from", "type": "address" }, {
            "indexed": false,
            "name": "to",
            "type": "address"
        }, { "indexed": false, "name": "value", "type": "uint256" }, {
            "indexed": false,
            "name": "tokenType",
            "type": "uint8"
        }, { "indexed": false, "name": "market", "type": "address" }]
    },
    '75dd618f69c0f07adc97fe19ba435f3932ce6aa8cad287fb9bdfaf37639f703a': {
        "name": "TokensMinted",
        "signature": "TokensMinted(address,address,address,uint256,uint8,address)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "token",
            "type": "address"
        }, { "indexed": true, "name": "target", "type": "address" }, {
            "indexed": false,
            "name": "amount",
            "type": "uint256"
        }, { "indexed": false, "name": "tokenType", "type": "uint8" }, {
            "indexed": false,
            "name": "market",
            "type": "address"
        }]
    },
    '262b80f2af08a1001d15a1df91dde9acb8441811543886659b3845a8c285748b': {
        "name": "TokensBurned",
        "signature": "TokensBurned(address,address,address,uint256,uint8,address)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "token",
            "type": "address"
        }, { "indexed": true, "name": "target", "type": "address" }, {
            "indexed": false,
            "name": "amount",
            "type": "uint256"
        }, { "indexed": false, "name": "tokenType", "type": "uint8" }, {
            "indexed": false,
            "name": "market",
            "type": "address"
        }]
    },
    '325bd163fbd5df8a29535541a0ea7312ae82a67c1ad3a3d692ccdb9a25f67634': {
        "name": "DisputeWindowCreated",
        "signature": "DisputeWindowCreated(address,address,uint256,uint256,uint256)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": false,
            "name": "disputeWindow",
            "type": "address"
        }, { "indexed": false, "name": "startTime", "type": "uint256" }, {
            "indexed": false,
            "name": "endTime",
            "type": "uint256"
        }, { "indexed": false, "name": "id", "type": "uint256" }]
    },
    'ee62c58e2603b92f96a002e012f4f3bd5748102cfa3b711f6d778c6237fcaa96': {
        "name": "InitialReporterTransferred",
        "signature": "InitialReporterTransferred(address,address,address,address)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "market",
            "type": "address"
        }, { "indexed": false, "name": "from", "type": "address" }, {
            "indexed": false,
            "name": "to",
            "type": "address"
        }]
    },
    '55f2a7bfa32e835c3f3c3cff653a3d11c077ce1b00c5a41c6aaf09eedc1ac3b2': {
        "name": "MarketTransferred",
        "signature": "MarketTransferred(address,address,address,address)",
        "parameters": [{ "indexed": true, "name": "universe", "type": "address" }, {
            "indexed": true,
            "name": "market",
            "type": "address"
        }, { "indexed": false, "name": "from", "type": "address" }, {
            "indexed": false,
            "name": "to",
            "type": "address"
        }]
    },
    '4b6202764c3d77dc2a0c06f5b94ed9051fca8b678f707f3e514479a2bc91eb66': {
        "name": "EscapeHatchChanged",
        "signature": "EscapeHatchChanged(bool)",
        "parameters": [{ "indexed": false, "name": "isOn", "type": "bool" }]
    },
    '11dda748f0bd3af85a073da0088a0acb827d9584a4fdb825c81f1232a5309538': {
        "name": "TimestampSet",
        "signature": "TimestampSet(uint256)",
        "parameters": [{ "indexed": false, "name": "newTimestamp", "type": "uint256" }]
    },
    '93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db153': {
        "name": "InterfaceImplementerSet",
        "signature": "InterfaceImplementerSet(address,bytes32,address)",
        "parameters": [{ "indexed": true, "name": "addr", "type": "address" }, {
            "indexed": true,
            "name": "interfaceHash",
            "type": "bytes32"
        }, { "indexed": true, "name": "implementer", "type": "address" }]
    },
    '605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a4350': {
        "name": "ManagerChanged",
        "signature": "ManagerChanged(address,address)",
        "parameters": [{ "indexed": true, "name": "addr", "type": "address" }, {
            "indexed": true,
            "name": "newManager",
            "type": "address"
        }]
    },
    'bf88b5a3158512dc8ad44dadf221f46eb1df762a2e7fd1de86aab34b0af455cf': {
        "name": "FundedAccount",
        "signature": "FundedAccount(address,address,uint256,uint256)",
        "parameters": [{ "indexed": true, "name": "_universe", "type": "address" }, {
            "indexed": true,
            "name": "_sender",
            "type": "address"
        }, { "indexed": false, "name": "_repBalance", "type": "uint256" }, {
            "indexed": false,
            "name": "_timestamp",
            "type": "uint256"
        }]
    },
    '0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885': {
        "name": "Mint",
        "signature": "Mint(address,uint256)",
        "parameters": [{ "indexed": true, "name": "target", "type": "address" }, {
            "indexed": false,
            "name": "value",
            "type": "uint256"
        }]
    },
    'cc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5': {
        "name": "Burn",
        "signature": "Burn(address,uint256)",
        "parameters": [{ "indexed": true, "name": "target", "type": "address" }, {
            "indexed": false,
            "name": "value",
            "type": "uint256"
        }]
    },
    'b531fea5aa9b801cfa979874223cdc61cc3691d97679ecbf9165d54b1bc3357a': {
        "name": "Sent",
        "signature": "Sent(address,address,address,uint256,bytes32,bytes32)",
        "parameters": [{ "indexed": true, "name": "operator", "type": "address" }, {
            "indexed": true,
            "name": "from",
            "type": "address"
        }, { "indexed": true, "name": "to", "type": "address" }, {
            "indexed": false,
            "name": "amount",
            "type": "uint256"
        }, { "indexed": false, "name": "data", "type": "bytes32" }, {
            "indexed": false,
            "name": "operatorData",
            "type": "bytes32"
        }]
    },
    '794f771c64c4db2f318b4519d7ddc0ccbe03f9a239852dbe286e32a140c188ce': {
        "name": "Minted",
        "signature": "Minted(address,address,uint256,bytes32)",
        "parameters": [{ "indexed": true, "name": "operator", "type": "address" }, {
            "indexed": true,
            "name": "to",
            "type": "address"
        }, { "indexed": false, "name": "amount", "type": "uint256" }, {
            "indexed": false,
            "name": "operatorData",
            "type": "bytes32"
        }]
    },
    '50c1bacbee5f911f0dbd7e235811ea8d16f220b78fa9e771ebff91202834b2fb': {
        "name": "Burned",
        "signature": "Burned(address,address,uint256,bytes32,bytes32)",
        "parameters": [{ "indexed": true, "name": "operator", "type": "address" }, {
            "indexed": true,
            "name": "from",
            "type": "address"
        }, { "indexed": false, "name": "amount", "type": "uint256" }, {
            "indexed": false,
            "name": "data",
            "type": "bytes32"
        }, { "indexed": false, "name": "operatorData", "type": "bytes32" }]
    },
    'f4caeb2d6ca8932a215a353d0703c326ec2d81fc68170f320eb2ab49e9df61f9': {
        "name": "AuthorizedOperator",
        "signature": "AuthorizedOperator(address,address)",
        "parameters": [{ "indexed": true, "name": "operator", "type": "address" }, {
            "indexed": true,
            "name": "tokenHolder",
            "type": "address"
        }]
    },
    '50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1': {
        "name": "RevokedOperator",
        "signature": "RevokedOperator(address,address)",
        "parameters": [{ "indexed": true, "name": "operator", "type": "address" }, {
            "indexed": true,
            "name": "tokenHolder",
            "type": "address"
        }]
    },
    'ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef': {
        "name": "Transfer",
        "signature": "Transfer(address,address,uint256)",
        "parameters": [{ "indexed": true, "name": "from", "type": "address" }, {
            "indexed": true,
            "name": "to",
            "type": "address"
        }, { "indexed": false, "name": "value", "type": "uint256" }]
    },
    '8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925': {
        "name": "Approval",
        "signature": "Approval(address,address,uint256)",
        "parameters": [{ "indexed": true, "name": "owner", "type": "address" }, {
            "indexed": true,
            "name": "spender",
            "type": "address"
        }, { "indexed": false, "name": "value", "type": "uint256" }]
    }
};

export namespace Augur {
    export interface MarketCreated<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'MarketCreated'
        parameters: {
            topic: Bytes32
            description: string
            extraInfo: string
            universe: Address
            market: Address
            marketCreator: Address
            outcomes: Array<Bytes32>
            marketCreationFee: UInt256<TLargeInteger>
            minPrice: Int256<TLargeInteger>
            maxPrice: Int256<TLargeInteger>
            marketType: UInt8
        }
    }
}

export namespace Augur {
    export interface InitialReportSubmitted<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'InitialReportSubmitted'
        parameters: {
            universe: Address
            reporter: Address
            market: Address
            amountStaked: UInt256<TLargeInteger>
            isDesignatedReporter: boolean
            payoutNumerators: Array<UInt256<TLargeInteger>>
            description: string
        }
    }
}

export namespace Augur {
    export interface DisputeCrowdsourcerCreated<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'DisputeCrowdsourcerCreated'
        parameters: {
            universe: Address
            market: Address
            disputeCrowdsourcer: Address
            payoutNumerators: Array<UInt256<TLargeInteger>>
            size: UInt256<TLargeInteger>
        }
    }
}

export namespace Augur {
    export interface DisputeCrowdsourcerContribution<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'DisputeCrowdsourcerContribution'
        parameters: {
            universe: Address
            reporter: Address
            market: Address
            disputeCrowdsourcer: Address
            amountStaked: UInt256<TLargeInteger>
            description: string
        }
    }
}

export namespace Augur {
    export interface DisputeCrowdsourcerCompleted<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'DisputeCrowdsourcerCompleted'
        parameters: {
            universe: Address
            market: Address
            disputeCrowdsourcer: Address
        }
    }
}

export namespace Augur {
    export interface InitialReporterRedeemed<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'InitialReporterRedeemed'
        parameters: {
            universe: Address
            reporter: Address
            market: Address
            amountRedeemed: UInt256<TLargeInteger>
            repReceived: UInt256<TLargeInteger>
            payoutNumerators: Array<UInt256<TLargeInteger>>
        }
    }
}

export namespace Augur {
    export interface DisputeCrowdsourcerRedeemed<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'DisputeCrowdsourcerRedeemed'
        parameters: {
            universe: Address
            reporter: Address
            market: Address
            disputeCrowdsourcer: Address
            amountRedeemed: UInt256<TLargeInteger>
            repReceived: UInt256<TLargeInteger>
            payoutNumerators: Array<UInt256<TLargeInteger>>
        }
    }
}

export namespace Augur {
    export interface ReportingParticipantDisavowed<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'ReportingParticipantDisavowed'
        parameters: {
            universe: Address
            market: Address
            reportingParticipant: Address
        }
    }
}

export namespace Augur {
    export interface MarketParticipantsDisavowed<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'MarketParticipantsDisavowed'
        parameters: {
            universe: Address
            market: Address
        }
    }
}

export namespace Augur {
    export interface MarketFinalized<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'MarketFinalized'
        parameters: {
            universe: Address
            market: Address
        }
    }
}

export namespace Augur {
    export interface MarketMigrated<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'MarketMigrated'
        parameters: {
            market: Address
            originalUniverse: Address
            newUniverse: Address
        }
    }
}

export namespace Augur {
    export interface UniverseForked<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'UniverseForked'
        parameters: {
            universe: Address
        }
    }
}

export namespace Augur {
    export interface UniverseCreated<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'UniverseCreated'
        parameters: {
            parentUniverse: Address
            childUniverse: Address
            payoutNumerators: Array<UInt256<TLargeInteger>>
        }
    }
}

export namespace Augur {
    export interface OrderCanceled<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'OrderCanceled'
        parameters: {
            universe: Address
            shareToken: Address
            sender: Address
            orderId: Bytes32
            orderType: UInt8
            tokenRefund: UInt256<TLargeInteger>
            sharesRefund: UInt256<TLargeInteger>
        }
    }
}

export namespace Augur {
    export interface OrderCreated<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'OrderCreated'
        parameters: {
            orderType: UInt8
            amount: UInt256<TLargeInteger>
            price: UInt256<TLargeInteger>
            creator: Address
            moneyEscrowed: UInt256<TLargeInteger>
            sharesEscrowed: UInt256<TLargeInteger>
            tradeGroupId: Bytes32
            orderId: Bytes32
            universe: Address
            shareToken: Address
        }
    }
}

export namespace Augur {
    export interface OrderFilled<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'OrderFilled'
        parameters: {
            universe: Address
            shareToken: Address
            filler: Address
            orderId: Bytes32
            numCreatorShares: UInt256<TLargeInteger>
            numCreatorTokens: UInt256<TLargeInteger>
            numFillerShares: UInt256<TLargeInteger>
            numFillerTokens: UInt256<TLargeInteger>
            marketCreatorFees: UInt256<TLargeInteger>
            reporterFees: UInt256<TLargeInteger>
            amountFilled: UInt256<TLargeInteger>
            tradeGroupId: Bytes32
        }
    }
}

export namespace Augur {
    export interface CompleteSetsPurchased<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'CompleteSetsPurchased'
        parameters: {
            universe: Address
            market: Address
            account: Address
            numCompleteSets: UInt256<TLargeInteger>
        }
    }
}

export namespace Augur {
    export interface CompleteSetsSold<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'CompleteSetsSold'
        parameters: {
            universe: Address
            market: Address
            account: Address
            numCompleteSets: UInt256<TLargeInteger>
        }
    }
}

export namespace Augur {
    export interface TradingProceedsClaimed<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'TradingProceedsClaimed'
        parameters: {
            universe: Address
            shareToken: Address
            sender: Address
            market: Address
            numShares: UInt256<TLargeInteger>
            numPayoutTokens: UInt256<TLargeInteger>
            finalTokenBalance: UInt256<TLargeInteger>
        }
    }
}

export namespace Augur {
    export interface TokensTransferred<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'TokensTransferred'
        parameters: {
            universe: Address
            token: Address
            from: Address
            to: Address
            value: UInt256<TLargeInteger>
            tokenType: UInt8
            market: Address
        }
    }
}

export namespace Augur {
    export interface TokensMinted<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'TokensMinted'
        parameters: {
            universe: Address
            token: Address
            target: Address
            amount: UInt256<TLargeInteger>
            tokenType: UInt8
            market: Address
        }
    }
}

export namespace Augur {
    export interface TokensBurned<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'TokensBurned'
        parameters: {
            universe: Address
            token: Address
            target: Address
            amount: UInt256<TLargeInteger>
            tokenType: UInt8
            market: Address
        }
    }
}

export namespace Augur {
    export interface DisputeWindowCreated<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'DisputeWindowCreated'
        parameters: {
            universe: Address
            disputeWindow: Address
            startTime: UInt256<TLargeInteger>
            endTime: UInt256<TLargeInteger>
            id: UInt256<TLargeInteger>
        }
    }
}

export namespace Augur {
    export interface InitialReporterTransferred<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'InitialReporterTransferred'
        parameters: {
            universe: Address
            market: Address
            from: Address
            to: Address
        }
    }
}

export namespace Augur {
    export interface MarketTransferred<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'MarketTransferred'
        parameters: {
            universe: Address
            market: Address
            from: Address
            to: Address
        }
    }
}

export namespace Augur {
    export interface EscapeHatchChanged<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'EscapeHatchChanged'
        parameters: {
            isOn: boolean
        }
    }
}

export namespace Augur {
    export interface TimestampSet<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'TimestampSet'
        parameters: {
            newTimestamp: UInt256<TLargeInteger>
        }
    }
}

export namespace ERC820Registry {
    export interface InterfaceImplementerSet<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'InterfaceImplementerSet'
        parameters: {
            addr: Address
            interfaceHash: Bytes32
            implementer: Address
        }
    }
}

export namespace ERC820Registry {
    export interface ManagerChanged<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'ManagerChanged'
        parameters: {
            addr: Address
            newManager: Address
        }
    }
}

export namespace LegacyReputationToken {
    export interface FundedAccount<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'FundedAccount'
        parameters: {
            _universe: Address
            _sender: Address
            _repBalance: UInt256<TLargeInteger>
            _timestamp: UInt256<TLargeInteger>
        }
    }
}

export namespace LegacyReputationToken {
    export interface Mint<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Mint'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace LegacyReputationToken {
    export interface Burn<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burn'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace LegacyReputationToken {
    export interface Sent<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Sent'
        parameters: {
            operator: Address
            from: Address
            to: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace LegacyReputationToken {
    export interface Minted<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Minted'
        parameters: {
            operator: Address
            to: Address
            amount: UInt256<TLargeInteger>
            operatorData: Bytes32
        }
    }
}

export namespace LegacyReputationToken {
    export interface Burned<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burned'
        parameters: {
            operator: Address
            from: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace LegacyReputationToken {
    export interface AuthorizedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'AuthorizedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace LegacyReputationToken {
    export interface RevokedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'RevokedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace LegacyReputationToken {
    export interface Transfer<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Transfer'
        parameters: {
            from: Address
            to: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace LegacyReputationToken {
    export interface Approval<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Approval'
        parameters: {
            owner: Address
            spender: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace TestNetReputationToken {
    export interface Mint<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Mint'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace TestNetReputationToken {
    export interface Burn<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burn'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace TestNetReputationToken {
    export interface Sent<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Sent'
        parameters: {
            operator: Address
            from: Address
            to: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace TestNetReputationToken {
    export interface Minted<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Minted'
        parameters: {
            operator: Address
            to: Address
            amount: UInt256<TLargeInteger>
            operatorData: Bytes32
        }
    }
}

export namespace TestNetReputationToken {
    export interface Burned<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burned'
        parameters: {
            operator: Address
            from: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace TestNetReputationToken {
    export interface AuthorizedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'AuthorizedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace TestNetReputationToken {
    export interface RevokedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'RevokedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace TestNetReputationToken {
    export interface Transfer<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Transfer'
        parameters: {
            from: Address
            to: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace TestNetReputationToken {
    export interface Approval<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Approval'
        parameters: {
            owner: Address
            spender: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace AuctionToken {
    export interface Mint<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Mint'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace AuctionToken {
    export interface Burn<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burn'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace AuctionToken {
    export interface Sent<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Sent'
        parameters: {
            operator: Address
            from: Address
            to: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace AuctionToken {
    export interface Minted<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Minted'
        parameters: {
            operator: Address
            to: Address
            amount: UInt256<TLargeInteger>
            operatorData: Bytes32
        }
    }
}

export namespace AuctionToken {
    export interface Burned<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burned'
        parameters: {
            operator: Address
            from: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace AuctionToken {
    export interface AuthorizedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'AuthorizedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace AuctionToken {
    export interface RevokedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'RevokedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace AuctionToken {
    export interface Transfer<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Transfer'
        parameters: {
            from: Address
            to: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace AuctionToken {
    export interface Approval<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Approval'
        parameters: {
            owner: Address
            spender: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace DisputeCrowdsourcer {
    export interface Mint<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Mint'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace DisputeCrowdsourcer {
    export interface Burn<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burn'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace DisputeCrowdsourcer {
    export interface Sent<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Sent'
        parameters: {
            operator: Address
            from: Address
            to: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace DisputeCrowdsourcer {
    export interface Minted<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Minted'
        parameters: {
            operator: Address
            to: Address
            amount: UInt256<TLargeInteger>
            operatorData: Bytes32
        }
    }
}

export namespace DisputeCrowdsourcer {
    export interface Burned<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burned'
        parameters: {
            operator: Address
            from: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace DisputeCrowdsourcer {
    export interface AuthorizedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'AuthorizedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace DisputeCrowdsourcer {
    export interface RevokedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'RevokedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace DisputeCrowdsourcer {
    export interface Transfer<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Transfer'
        parameters: {
            from: Address
            to: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace DisputeCrowdsourcer {
    export interface Approval<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Approval'
        parameters: {
            owner: Address
            spender: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace ReputationToken {
    export interface Mint<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Mint'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace ReputationToken {
    export interface Burn<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burn'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace ReputationToken {
    export interface Sent<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Sent'
        parameters: {
            operator: Address
            from: Address
            to: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace ReputationToken {
    export interface Minted<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Minted'
        parameters: {
            operator: Address
            to: Address
            amount: UInt256<TLargeInteger>
            operatorData: Bytes32
        }
    }
}

export namespace ReputationToken {
    export interface Burned<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burned'
        parameters: {
            operator: Address
            from: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace ReputationToken {
    export interface AuthorizedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'AuthorizedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace ReputationToken {
    export interface RevokedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'RevokedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace ReputationToken {
    export interface Transfer<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Transfer'
        parameters: {
            from: Address
            to: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace ReputationToken {
    export interface Approval<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Approval'
        parameters: {
            owner: Address
            spender: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace Cash {
    export interface Mint<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Mint'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace Cash {
    export interface Burn<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burn'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace Cash {
    export interface Sent<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Sent'
        parameters: {
            operator: Address
            from: Address
            to: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace Cash {
    export interface Minted<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Minted'
        parameters: {
            operator: Address
            to: Address
            amount: UInt256<TLargeInteger>
            operatorData: Bytes32
        }
    }
}

export namespace Cash {
    export interface Burned<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burned'
        parameters: {
            operator: Address
            from: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace Cash {
    export interface AuthorizedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'AuthorizedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace Cash {
    export interface RevokedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'RevokedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace Cash {
    export interface Transfer<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Transfer'
        parameters: {
            from: Address
            to: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace Cash {
    export interface Approval<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Approval'
        parameters: {
            owner: Address
            spender: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace ShareToken {
    export interface Mint<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Mint'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace ShareToken {
    export interface Burn<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burn'
        parameters: {
            target: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace ShareToken {
    export interface Sent<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Sent'
        parameters: {
            operator: Address
            from: Address
            to: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace ShareToken {
    export interface Minted<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Minted'
        parameters: {
            operator: Address
            to: Address
            amount: UInt256<TLargeInteger>
            operatorData: Bytes32
        }
    }
}

export namespace ShareToken {
    export interface Burned<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Burned'
        parameters: {
            operator: Address
            from: Address
            amount: UInt256<TLargeInteger>
            data: Bytes32
            operatorData: Bytes32
        }
    }
}

export namespace ShareToken {
    export interface AuthorizedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'AuthorizedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace ShareToken {
    export interface RevokedOperator<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'RevokedOperator'
        parameters: {
            operator: Address
            tokenHolder: Address
        }
    }
}

export namespace ShareToken {
    export interface Transfer<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Transfer'
        parameters: {
            from: Address
            to: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export namespace ShareToken {
    export interface Approval<TLargeInteger> extends DecodedEvent<TLargeInteger> {
        name: 'Approval'
        parameters: {
            owner: Address
            spender: Address
            value: UInt256<TLargeInteger>
        }
    }
}

export type Event<TLargeInteger> =
    DecodedEvent<TLargeInteger>
    | Augur.MarketCreated<TLargeInteger>
    | Augur.InitialReportSubmitted<TLargeInteger>
    | Augur.DisputeCrowdsourcerCreated<TLargeInteger>
    | Augur.DisputeCrowdsourcerContribution<TLargeInteger>
    | Augur.DisputeCrowdsourcerCompleted<TLargeInteger>
    | Augur.InitialReporterRedeemed<TLargeInteger>
    | Augur.DisputeCrowdsourcerRedeemed<TLargeInteger>
    | Augur.ReportingParticipantDisavowed<TLargeInteger>
    | Augur.MarketParticipantsDisavowed<TLargeInteger>
    | Augur.MarketFinalized<TLargeInteger>
    | Augur.MarketMigrated<TLargeInteger>
    | Augur.UniverseForked<TLargeInteger>
    | Augur.UniverseCreated<TLargeInteger>
    | Augur.OrderCanceled<TLargeInteger>
    | Augur.OrderCreated<TLargeInteger>
    | Augur.OrderFilled<TLargeInteger>
    | Augur.CompleteSetsPurchased<TLargeInteger>
    | Augur.CompleteSetsSold<TLargeInteger>
    | Augur.TradingProceedsClaimed<TLargeInteger>
    | Augur.TokensTransferred<TLargeInteger>
    | Augur.TokensMinted<TLargeInteger>
    | Augur.TokensBurned<TLargeInteger>
    | Augur.DisputeWindowCreated<TLargeInteger>
    | Augur.InitialReporterTransferred<TLargeInteger>
    | Augur.MarketTransferred<TLargeInteger>
    | Augur.EscapeHatchChanged<TLargeInteger>
    | Augur.TimestampSet<TLargeInteger>
    | ERC820Registry.InterfaceImplementerSet<TLargeInteger>
    | ERC820Registry.ManagerChanged<TLargeInteger>
    | LegacyReputationToken.FundedAccount<TLargeInteger>
    | LegacyReputationToken.Mint<TLargeInteger>
    | LegacyReputationToken.Burn<TLargeInteger>
    | LegacyReputationToken.Sent<TLargeInteger>
    | LegacyReputationToken.Minted<TLargeInteger>
    | LegacyReputationToken.Burned<TLargeInteger>
    | LegacyReputationToken.AuthorizedOperator<TLargeInteger>
    | LegacyReputationToken.RevokedOperator<TLargeInteger>
    | LegacyReputationToken.Transfer<TLargeInteger>
    | LegacyReputationToken.Approval<TLargeInteger>
    | TestNetReputationToken.Mint<TLargeInteger>
    | TestNetReputationToken.Burn<TLargeInteger>
    | TestNetReputationToken.Sent<TLargeInteger>
    | TestNetReputationToken.Minted<TLargeInteger>
    | TestNetReputationToken.Burned<TLargeInteger>
    | TestNetReputationToken.AuthorizedOperator<TLargeInteger>
    | TestNetReputationToken.RevokedOperator<TLargeInteger>
    | TestNetReputationToken.Transfer<TLargeInteger>
    | TestNetReputationToken.Approval<TLargeInteger>
    | AuctionToken.Mint<TLargeInteger>
    | AuctionToken.Burn<TLargeInteger>
    | AuctionToken.Sent<TLargeInteger>
    | AuctionToken.Minted<TLargeInteger>
    | AuctionToken.Burned<TLargeInteger>
    | AuctionToken.AuthorizedOperator<TLargeInteger>
    | AuctionToken.RevokedOperator<TLargeInteger>
    | AuctionToken.Transfer<TLargeInteger>
    | AuctionToken.Approval<TLargeInteger>
    | DisputeCrowdsourcer.Mint<TLargeInteger>
    | DisputeCrowdsourcer.Burn<TLargeInteger>
    | DisputeCrowdsourcer.Sent<TLargeInteger>
    | DisputeCrowdsourcer.Minted<TLargeInteger>
    | DisputeCrowdsourcer.Burned<TLargeInteger>
    | DisputeCrowdsourcer.AuthorizedOperator<TLargeInteger>
    | DisputeCrowdsourcer.RevokedOperator<TLargeInteger>
    | DisputeCrowdsourcer.Transfer<TLargeInteger>
    | DisputeCrowdsourcer.Approval<TLargeInteger>
    | ReputationToken.Mint<TLargeInteger>
    | ReputationToken.Burn<TLargeInteger>
    | ReputationToken.Sent<TLargeInteger>
    | ReputationToken.Minted<TLargeInteger>
    | ReputationToken.Burned<TLargeInteger>
    | ReputationToken.AuthorizedOperator<TLargeInteger>
    | ReputationToken.RevokedOperator<TLargeInteger>
    | ReputationToken.Transfer<TLargeInteger>
    | ReputationToken.Approval<TLargeInteger>
    | Cash.Mint<TLargeInteger>
    | Cash.Burn<TLargeInteger>
    | Cash.Sent<TLargeInteger>
    | Cash.Minted<TLargeInteger>
    | Cash.Burned<TLargeInteger>
    | Cash.AuthorizedOperator<TLargeInteger>
    | Cash.RevokedOperator<TLargeInteger>
    | Cash.Transfer<TLargeInteger>
    | Cash.Approval<TLargeInteger>
    | ShareToken.Mint<TLargeInteger>
    | ShareToken.Burn<TLargeInteger>
    | ShareToken.Sent<TLargeInteger>
    | ShareToken.Minted<TLargeInteger>
    | ShareToken.Burned<TLargeInteger>
    | ShareToken.AuthorizedOperator<TLargeInteger>
    | ShareToken.RevokedOperator<TLargeInteger>
    | ShareToken.Transfer<TLargeInteger>
    | ShareToken.Approval<TLargeInteger>


export interface Dependencies<TLargeInteger> {
    call(transaction: Transaction<TLargeInteger>): Promise<Uint8Array>

    submitTransaction(transaction: Transaction<TLargeInteger>): Promise<TransactionReceipt>

    isLargeInteger(x: any): x is TLargeInteger

    encodeLargeUnsignedInteger(x: TLargeInteger): Bytes32

    encodeLargeSignedInteger(x: TLargeInteger): Bytes32

    decodeLargeUnsignedInteger(data: Bytes32): TLargeInteger

    decodeLargeSignedInteger(data: Bytes32): TLargeInteger
}


/**
 * By convention, pure/view methods have a `_` suffix on them indicating to the caller that the function will be executed locally and return the function's result.  payable/nonpayable functions have both a local version and a remote version (distinguished by the trailing `_`).  If the remote method is called, you will only get back a transaction hash which can be used to lookup the transaction receipt for success/failure (due to EVM limitations you will not get the function results back).
 */
export class Contract<TLargeInteger> {
    protected constructor(protected readonly dependencies: Dependencies<TLargeInteger>, public readonly address: Address) {
    }

    public decodeParameters(descriptions: Array<ParameterDescription>, data: Uint8Array): EncodableTuple<TLargeInteger> {
        let offset = 0;
        const decoded: EncodableTuple<TLargeInteger> = {};
        for (let description of descriptions) {
            const { result, consumed } = this.decodeParameter(description, data, offset);
            offset += consumed;
            // it is possible that name is missing/null/empty string if there is only a single parameter, in which case we use the placeholder name 'result'
            decoded[description.name || 'result'] = result
        }
        return decoded
    }

    public encodeParameters(descriptions: Array<ParameterDescription>, parameters: Array<Encodable<TLargeInteger>>): Bytes {
        if (descriptions.length !== parameters.length) throw new Error(`Number of provided parameters (${parameters.length}) does not match number of expected parameters (${descriptions.length})`);
        const encodedParameters = parameters.map((nestedParameter, index) => this.encodeParameter(descriptions[index], nestedParameter));
        return encodeDynamicData(encodedParameters)
    }

    protected async localCall(signatureHash: SignatureHash, inputParameterDescriptions: Array<ParameterDescription>, outputParameterDescriptions: Array<ParameterDescription>, parameters: Array<any>, attachedEth?: UInt256<TLargeInteger>): Promise<EncodableTuple<TLargeInteger>> {
        const data = this.encodeMethod(signatureHash, inputParameterDescriptions, parameters);
        const transaction = Object.assign({ to: this.address, data: data }, attachedEth ? { value: attachedEth } : {});
        const result = await this.dependencies.call(transaction);
        return this.decodeParameters(outputParameterDescriptions, result)
    }

    protected async remoteCall(signatureHash: SignatureHash, inputParameterDescriptions: Array<ParameterDescription>, parameters: Array<any>, errorContext: { transactionName: string }, attachedEth?: UInt256<TLargeInteger>): Promise<Array<Event<TLargeInteger>>> {
        const data = this.encodeMethod(signatureHash, inputParameterDescriptions, parameters);
        const transaction = Object.assign({ to: this.address, data: data }, attachedEth ? { value: attachedEth } : {});
        const transactionReceipt = await this.dependencies.submitTransaction(transaction);
        if (!transactionReceipt.success) {
            throw new Error(`Remote call of ${errorContext.transactionName} failed: ${JSON.stringify(transactionReceipt)}`)
        }
        return this.decodeEvents(transactionReceipt.events)
    }

    private encodeMethod(signatureHash: SignatureHash, parameterDescriptions: Array<ParameterDescription>, parameters: Array<Encodable<TLargeInteger>>): Bytes {
        const parameterBytes = this.encodeParameters(parameterDescriptions, parameters);
        return concatenateBytes([signatureHash, parameterBytes])
    }

    private decodeEvents(encodedEvents: Array<EncodedEvent>): Array<Event<TLargeInteger>> {
        const decodedEvents: Array<DecodedEvent<TLargeInteger>> = [];
        encodedEvents.forEach(encodedEvent => {
            const decodedEvent = this.tryDecodeEvent(encodedEvent);
			if (decodedEvent) decodedEvents.push(decodedEvent)
        });
        return decodedEvents as Array<Event<TLargeInteger>>
    }

    private tryDecodeEvent(encodedEvent: EncodedEvent): DecodedEvent<TLargeInteger> | null {
        const signatureHash = encodedEvent.topics[0];
        const eventDescription = eventDescriptions[signatureHash.toString()];
        if (!eventDescription) return null;
        const parameters = this.decodeEventParameters(eventDescription.parameters, encodedEvent.topics, encodedEvent.data, { eventSignature: eventDescription.signature });
		return { name: eventDescription.name, parameters: parameters }
	}

    private stringifyParams(params: Array<ParameterDescription>): Array<string> {
		return params.map(param => {
			if (param.type === 'tuple') {
                if (!param.components) throw new Error(`Expected components when type is ${param.type}`);
				return `(${this.stringifyParams(param.components).join(',')})`
			} else if (param.type === 'tuple[]') {
                if (!param.components) throw new Error(`Expected components when type is ${param.type}`);
				return `(${this.stringifyParams(param.components).join(',')})[]`
			} else {
				return param.type
			}
		})
	}


    // decoding

    private decodeEventParameters(parameters: Array<EventParameterDescription>, topics: Array<Bytes32>, data: Bytes, errorContext: { eventSignature: string }): EncodableTuple<TLargeInteger> {
        const indexedTypesForDecoding = parameters.filter(parameter => parameter.indexed).map(this.getTypeForEventDecoding);
        const nonIndexedTypesForDecoding = parameters.filter(parameter => !parameter.indexed);
        const indexedData = concatenateBytes(topics.slice(1));
        const nonIndexedData = data;
        const decodedIndexedParameters = this.decodeParameters(indexedTypesForDecoding, indexedData);
        if (!decodedIndexedParameters) throw new Error(`Failed to decode topics for event ${errorContext.eventSignature}.\n${indexedData}`);
        const decodedNonIndexedParameters = this.decodeParameters(nonIndexedTypesForDecoding, nonIndexedData);
        if (!decodedNonIndexedParameters) throw new Error(`Failed to decode data for event ${errorContext.eventSignature}.\n${nonIndexedData}`);
        return Object.assign({}, decodedIndexedParameters, decodedNonIndexedParameters)
    }

    private getTypeForEventDecoding(parameter: EventParameterDescription): EventParameterDescription {
        if (!parameter.indexed) return parameter;
		if (parameter.type !== 'string'
			&& parameter.type !== 'bytes'
            // TODO: check to see if we need to collapse fixed size tuples or not
			&& !parameter.type.startsWith('tuple')
            // TODO: check to see if we need to collapse fixed length arrays here or not
			&& !parameter.type.endsWith('[]'))
            return parameter;
		return Object.assign({}, parameter, { type: 'bytes32' })
	}

    private decodeParameter(description: ParameterDescription, data: Uint8Array, offset: number): { result: Encodable<TLargeInteger>, consumed: number } {
        return this.tryDecodeFixedArray(description, data, offset)
            || this.tryDecodeDynamicArray(description, data, offset)
            || this.tryDecodeTuple(description, data, offset)
            || this.tryDecodeDynamicBytes(description, data, offset)
            || this.tryDecodeString(description, data, offset)
            || this.tryDecodeBoolean(description, data, offset)
            || this.tryDecodeSmallNumber(description, data, offset)
            || this.tryDecodeLargeNumber(description, data, offset)
            || this.tryDecodeAddress(description, data, offset)
            || this.tryDecodeFixedBytes(description, data, offset)
            || this.tryDecodeFixedPointNumber(description, data, offset)
            || this.tryDecodeFunction(description, data, offset)
            || function() {
                throw new Error(`Unsupported parameter type ${description.type}`)
            }()
    }

    private tryDecodeFixedArray(description: ParameterDescription, data: Uint8Array, offset: number): { result: EncodableArray<TLargeInteger>, consumed: number } | null {
        const match = /^(.*)\[(\d+)\]$/.exec(description.type);
        if (match === null) return null;
        const subdescription = Object.assign({}, description, { type: match[1] });
        const length = Number.parseInt(match[2], 10);
        if (isDynamic(subdescription)) {
            const pointer = decodeSmallInteger(new Bytes32().from(data.subarray(offset, offset + 32)));
            const result: EncodableArray<TLargeInteger> = [];
            let consumed = 0;
            for (let i = 0; i < length; ++i) {
                const { result: itemResult, consumed: itemConsumed } = this.decodeParameter(subdescription, data.subarray(pointer), consumed);
                consumed += itemConsumed;
                result.push(itemResult)
            }
            return { result, consumed }
        } else {
            const result: EncodableArray<TLargeInteger> = [];
            let consumed = 0;
            for (let i = 0; i < length; ++i) {
                const { result: itemResult, consumed: itemConsumed } = this.decodeParameter(subdescription, data, offset + consumed);
                consumed += itemConsumed;
                result.push(itemResult)
            }
            return { result, consumed }
        }
    }

    private tryDecodeDynamicArray(description: ParameterDescription, data: Uint8Array, offset: number): { result: EncodableArray<TLargeInteger>, consumed: number } | null {
        if (!description.type.endsWith('[]')) return null;
        const subtype = description.type.substring(0, description.type.length - 2);
        const subdescription = Object.assign({}, description, { type: subtype });
        const pointer = decodeSmallInteger(new Bytes32().from(data.subarray(offset, offset + 32)));
        const length = decodeSmallInteger(new Bytes32().from(data.subarray(pointer, pointer + 32)));
        const result: EncodableArray<TLargeInteger> = [];
        let consumed = 0;
        for (let i = 0; i < length; ++i) {
            const { result: itemResult, consumed: itemConsumed } = this.decodeParameter(subdescription, data.subarray(pointer + 32), consumed);
            consumed += itemConsumed;
            result.push(itemResult)
        }
        return { result, consumed }
    }

    private tryDecodeTuple(description: ParameterDescription, data: Uint8Array, offset: number): { result: EncodableTuple<TLargeInteger>, consumed: number } | null {
        if (description.type !== 'tuple') return null;
        const result: EncodableTuple<TLargeInteger> = {};
        let consumed: number = 0;
        if (description.components === undefined || description.components.length === 0) {
        } else if (anyIsDynamic(description.components)) {
            const pointer = decodeSmallInteger(new Bytes32().from(data.subarray(offset, offset + 32)));
            for (let component of description.components) {
                const { result: componentResult, consumed: componentConsumed } = this.decodeParameter(component, data.subarray(pointer), consumed);
                consumed += componentConsumed;
                result[component.name] = componentResult
            }
            // from the point of view of the caller, we only consumed 32 bytes (the pointer)
            consumed = 32
        } else {
            for (let component of description.components) {
                const { result: componentResult, consumed: componentConsumed } = this.decodeParameter(component, data, offset + consumed);
                consumed += componentConsumed;
                result[component.name] = componentResult
            }
        }
        return { result, consumed }
    }

    private tryDecodeDynamicBytes(description: ParameterDescription, data: Uint8Array, offset: number): { result: Bytes, consumed: 32 } | null {
        if (description.type !== 'bytes') return null;
        const pointer = decodeSmallInteger(new Bytes32().from(data.subarray(offset, offset + 32)));
        const length = decodeSmallInteger(new Bytes32().from(data.subarray(pointer, pointer + 32)));
        const bytes = new Bytes(length).from(data.subarray(pointer + 32, pointer + 32 + length));
        return { result: bytes, consumed: 32 }
    }

    private tryDecodeString(description: ParameterDescription, data: Uint8Array, offset: number): { result: string, consumed: 32 } | null {
        if (description.type !== 'string') return null;
        const pointer = decodeSmallInteger(new Bytes32().from(data.subarray(offset, offset + 32)));
        const length = decodeSmallInteger(new Bytes32().from(data.subarray(pointer, pointer + 32)));
        const bytes = new Bytes(length).from(data.subarray(pointer + 32, pointer + 32 + length));
        const decoded = createTextDecoder().decode(bytes);
        return { result: decoded, consumed: 32 }
    }

    private tryDecodeBoolean(description: ParameterDescription, data: Uint8Array, offset: number): { result: boolean, consumed: 32 } | null {
        if (description.type !== 'bool') return null;
        const bytes = new Bytes32().from(data.subarray(offset, offset + 32));
        const decoded = decodeSmallInteger(bytes);
        return { result: !!decoded, consumed: 32 }
    }

    private tryDecodeSmallNumber(description: ParameterDescription, data: Uint8Array, offset: number): { result: SmallNumberLike, consumed: 32 } | null {
        const match = /^(u?)int(\d*)$/.exec(description.type);
        if (match === null) return null;
        const size = Number.parseInt(match[2]);
        if (size >= 40) return null;
        const signed = !match[1];
        const bytes = new Bytes32().from(data.subarray(offset, offset + 32));
        const decoded = decodeSmallInteger(bytes);
        if (!signed && size === 8) return { result: decoded as UInt8, consumed: 32 };
        else if (!signed && size === 16) return { result: decoded as UInt16, consumed: 32 };
        else if (!signed && size === 24) return { result: decoded as UInt24, consumed: 32 };
        else if (!signed && size === 32) return { result: decoded as UInt32, consumed: 32 };
        else if (signed && size === 8) return { result: decoded as Int8, consumed: 32 };
        else if (signed && size === 16) return { result: decoded as Int16, consumed: 32 };
        else if (signed && size === 24) return { result: decoded as Int24, consumed: 32 };
        else if (signed && size === 32) return { result: decoded as Int32, consumed: 32 };
        else return null
    }

    private tryDecodeLargeNumber(description: ParameterDescription, data: Uint8Array, offset: number): { result: LargeNumberLike<TLargeInteger>, consumed: 32 } | null {
        const match = /^(u?)int(\d*)$/.exec(description.type);
        if (match === null) return null;
        const size = Number.parseInt(match[2]);
        if (size <= 32) return null;
        const signed = !match[1];
        const bytes = new Bytes32().from(data.subarray(offset, offset + 32));
        const decoded = signed ? this.dependencies.decodeLargeSignedInteger(bytes) : this.dependencies.decodeLargeUnsignedInteger(bytes);
        if (!signed && size == 256) return { result: decoded as Int256<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 248) return { result: decoded as Int248<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 240) return { result: decoded as Int240<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 232) return { result: decoded as Int232<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 224) return { result: decoded as Int224<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 216) return { result: decoded as Int216<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 208) return { result: decoded as Int208<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 200) return { result: decoded as Int200<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 192) return { result: decoded as Int192<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 184) return { result: decoded as Int184<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 176) return { result: decoded as Int176<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 168) return { result: decoded as Int168<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 160) return { result: decoded as Int160<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 152) return { result: decoded as Int152<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 144) return { result: decoded as Int144<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 136) return { result: decoded as Int136<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 128) return { result: decoded as Int128<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 120) return { result: decoded as Int120<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 112) return { result: decoded as Int112<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 104) return { result: decoded as Int104<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 96) return { result: decoded as Int96<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 88) return { result: decoded as Int88<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 80) return { result: decoded as Int80<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 72) return { result: decoded as Int72<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 64) return { result: decoded as Int64<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 56) return { result: decoded as Int56<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 48) return { result: decoded as Int48<TLargeInteger>, consumed: 32 };
        else if (!signed && size == 40) return { result: decoded as Int40<TLargeInteger>, consumed: 32 };
        else if (signed && size == 256) return { result: decoded as UInt256<TLargeInteger>, consumed: 32 };
        else if (signed && size == 248) return { result: decoded as UInt248<TLargeInteger>, consumed: 32 };
        else if (signed && size == 240) return { result: decoded as UInt240<TLargeInteger>, consumed: 32 };
        else if (signed && size == 232) return { result: decoded as UInt232<TLargeInteger>, consumed: 32 };
        else if (signed && size == 224) return { result: decoded as UInt224<TLargeInteger>, consumed: 32 };
        else if (signed && size == 216) return { result: decoded as UInt216<TLargeInteger>, consumed: 32 };
        else if (signed && size == 208) return { result: decoded as UInt208<TLargeInteger>, consumed: 32 };
        else if (signed && size == 200) return { result: decoded as UInt200<TLargeInteger>, consumed: 32 };
        else if (signed && size == 192) return { result: decoded as UInt192<TLargeInteger>, consumed: 32 };
        else if (signed && size == 184) return { result: decoded as UInt184<TLargeInteger>, consumed: 32 };
        else if (signed && size == 176) return { result: decoded as UInt176<TLargeInteger>, consumed: 32 };
        else if (signed && size == 168) return { result: decoded as UInt168<TLargeInteger>, consumed: 32 };
        else if (signed && size == 160) return { result: decoded as UInt160<TLargeInteger>, consumed: 32 };
        else if (signed && size == 152) return { result: decoded as UInt152<TLargeInteger>, consumed: 32 };
        else if (signed && size == 144) return { result: decoded as UInt144<TLargeInteger>, consumed: 32 };
        else if (signed && size == 136) return { result: decoded as UInt136<TLargeInteger>, consumed: 32 };
        else if (signed && size == 128) return { result: decoded as UInt128<TLargeInteger>, consumed: 32 };
        else if (signed && size == 120) return { result: decoded as UInt120<TLargeInteger>, consumed: 32 };
        else if (signed && size == 112) return { result: decoded as UInt112<TLargeInteger>, consumed: 32 };
        else if (signed && size == 104) return { result: decoded as UInt104<TLargeInteger>, consumed: 32 };
        else if (signed && size == 96) return { result: decoded as UInt96<TLargeInteger>, consumed: 32 };
        else if (signed && size == 88) return { result: decoded as UInt88<TLargeInteger>, consumed: 32 };
        else if (signed && size == 80) return { result: decoded as UInt80<TLargeInteger>, consumed: 32 };
        else if (signed && size == 72) return { result: decoded as UInt72<TLargeInteger>, consumed: 32 };
        else if (signed && size == 64) return { result: decoded as UInt64<TLargeInteger>, consumed: 32 };
        else if (signed && size == 56) return { result: decoded as UInt56<TLargeInteger>, consumed: 32 };
        else if (signed && size == 48) return { result: decoded as UInt48<TLargeInteger>, consumed: 32 };
        else if (signed && size == 40) return { result: decoded as UInt40<TLargeInteger>, consumed: 32 };
        else return null
    }

    private tryDecodeAddress(description: ParameterDescription, data: Uint8Array, offset: number): { result: Address, consumed: 32 } | null {
        if (description.type !== 'address') return null;
        return { result: new Address().from(data.subarray(offset + 12, offset + 32)), consumed: 32 }
    }

    private tryDecodeFixedBytes(description: ParameterDescription, data: Uint8Array, offset: number): { result: FixedBytesLike, consumed: 32 } | null {
        const match = /^bytes(\d+)$/.exec(description.type);
        if (match === null) return null;
        const size = Number.parseInt(match[1]);
        const dataSubset = data.subarray(offset, offset + size);
        if (size == 32) return { result: new Bytes32().from(dataSubset), consumed: 32 };
        else if (size == 31) return { result: new Bytes31().from(dataSubset), consumed: 32 };
        else if (size == 30) return { result: new Bytes30().from(dataSubset), consumed: 32 };
        else if (size == 29) return { result: new Bytes29().from(dataSubset), consumed: 32 };
        else if (size == 28) return { result: new Bytes28().from(dataSubset), consumed: 32 };
        else if (size == 27) return { result: new Bytes27().from(dataSubset), consumed: 32 };
        else if (size == 26) return { result: new Bytes26().from(dataSubset), consumed: 32 };
        else if (size == 25) return { result: new Bytes25().from(dataSubset), consumed: 32 };
        else if (size == 24) return { result: new Bytes24().from(dataSubset), consumed: 32 };
        else if (size == 23) return { result: new Bytes23().from(dataSubset), consumed: 32 };
        else if (size == 22) return { result: new Bytes22().from(dataSubset), consumed: 32 };
        else if (size == 21) return { result: new Bytes21().from(dataSubset), consumed: 32 };
        else if (size == 20) return { result: new Bytes20().from(dataSubset), consumed: 32 };
        else if (size == 19) return { result: new Bytes19().from(dataSubset), consumed: 32 };
        else if (size == 18) return { result: new Bytes18().from(dataSubset), consumed: 32 };
        else if (size == 17) return { result: new Bytes17().from(dataSubset), consumed: 32 };
        else if (size == 16) return { result: new Bytes16().from(dataSubset), consumed: 32 };
        else if (size == 15) return { result: new Bytes15().from(dataSubset), consumed: 32 };
        else if (size == 14) return { result: new Bytes14().from(dataSubset), consumed: 32 };
        else if (size == 13) return { result: new Bytes13().from(dataSubset), consumed: 32 };
        else if (size == 12) return { result: new Bytes12().from(dataSubset), consumed: 32 };
        else if (size == 11) return { result: new Bytes11().from(dataSubset), consumed: 32 };
        else if (size == 10) return { result: new Bytes10().from(dataSubset), consumed: 32 };
        else if (size == 9) return { result: new Bytes9().from(dataSubset), consumed: 32 };
        else if (size == 8) return { result: new Bytes8().from(dataSubset), consumed: 32 };
        else if (size == 7) return { result: new Bytes7().from(dataSubset), consumed: 32 };
        else if (size == 6) return { result: new Bytes6().from(dataSubset), consumed: 32 };
        else if (size == 5) return { result: new Bytes5().from(dataSubset), consumed: 32 };
        else if (size == 4) return { result: new Bytes4().from(dataSubset), consumed: 32 };
        else if (size == 3) return { result: new Bytes3().from(dataSubset), consumed: 32 };
        else if (size == 2) return { result: new Bytes2().from(dataSubset), consumed: 32 };
        else if (size == 1) return { result: new Bytes1().from(dataSubset), consumed: 32 };
        return null
    }

    private tryDecodeFixedPointNumber(description: ParameterDescription, data: Uint8Array, offset: number): never | null {
        if (!/^u?fixed\d+x\d+$/.test(description.type)) return null;
        throw new Error(`Encoding an EVM type ${description.type} is not supported`)
    }


    // encoding

    private tryDecodeFunction(description: ParameterDescription, data: Uint8Array, offset: number): never | null {
        if (description.type !== 'function') return null;
        throw new Error(`Decoding an EVM type ${description.type} is not supported`)
    }

    private encodeParameter(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: boolean, bytes: Uint8Array } {
        return this.tryEncodeFixedArray(description, parameter)
            || this.tryEncodeDynamicArray(description, parameter)
            || this.tryEncodeTuple(description, parameter)
            || this.tryEncodeDynamicBytes(description, parameter)
            || this.tryEncodeString(description, parameter)
            || this.tryEncodeBoolean(description, parameter)
            || this.tryEncodeSmallNumber(description, parameter)
            || this.tryEncodeLargeNumber(description, parameter)
            || this.tryEncodeAddress(description, parameter)
            || this.tryEncodeFixedBytes(description, parameter)
            || this.tryEncodeFixedPointNumber(description)
            || this.tryEncodeFunction(description)
            || function() {
                throw new Error(`Unsupported parameter type ${description.type}`)
            }()
    }

    private tryEncodeFixedArray(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: boolean, bytes: Uint8Array } | null {
        const match = /^(.*)\[(\d+)\]$/.exec(description.type);
        if (match === null) return null;
        const size = Number.parseInt(match[2]);
        if (!Array.isArray(parameter) || parameter.length !== size) throw new Error(`Can only encode a JavaScript 'array' of length ${size} into an EVM 'array' of length ${size}\n${parameter}`);
        const nestedDescription = Object.assign({}, description, { type: match[1] });
        const encodedParameters = parameter.map(nestedParameter => this.encodeParameter(nestedDescription, nestedParameter));
        const isDynamic = encodedParameters.some(x => x.isDynamic);
        if (isDynamic) {
            return { isDynamic: isDynamic, bytes: encodeDynamicData(encodedParameters) }
        } else {
            return { isDynamic: isDynamic, bytes: concatenateBytes(encodedParameters.map(x => x.bytes)) }
        }
    }

    private tryEncodeDynamicArray(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: true, bytes: Uint8Array } | null {
        if (!description.type.endsWith('[]')) return null;
        if (!Array.isArray(parameter)) throw new Error(`Can only encode a JavaScript 'array' into an EVM 'array'\n${parameter}`);
        const nestedDescription = Object.assign({}, description, { type: description.type.substring(0, description.type.length - 2) });
        const encodedParameters = parameter.map(nestedParameter => this.encodeParameter(nestedDescription, nestedParameter));
        const lengthBytes = numberToBytes32(encodedParameters.length);
        return { isDynamic: true, bytes: concatenateBytes([lengthBytes, encodeDynamicData(encodedParameters)]) }
    }

    private tryEncodeTuple(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: boolean, bytes: Uint8Array } | null {
        if (description.type !== 'tuple') return null;
        if (typeof parameter !== 'object') throw new Error(`Can only encode a JavaScript 'object' into an EVM 'tuple'\n${parameter}`);
        if (description.components === undefined || description.components.length === 0) {
            return { isDynamic: false, bytes: new Bytes(0) }
        } else {
            const encodableTuple = parameter as EncodableTuple<TLargeInteger>;
            const encodedComponents = description.components.map(component => this.encodeParameter(component, encodableTuple[component.name]));
            const isDynamic = encodedComponents.some(x => x.isDynamic);
            return {
                isDynamic: isDynamic,
                bytes: isDynamic ? encodeDynamicData(encodedComponents) : concatenateBytes(encodedComponents.map(x => x.bytes))
            }
        }
    }

    private tryEncodeDynamicBytes(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: true, bytes: Uint8Array } | null {
        if (description.type !== 'bytes') return null;
        if (!(parameter instanceof Uint8Array)) throw new Error(`Can only encode a JavaScript 'Uint8Array' into EVM 'bytes'\n${parameter}`);
        return { isDynamic: true, bytes: padAndLengthPrefix(parameter) }
    }

    private tryEncodeString(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: true, bytes: Uint8Array } | null {
        if (description.type !== 'string') return null;
        if (typeof parameter !== 'string') throw new Error(`Can only encode a JavaScript 'string' into an EVM 'string'\n${parameter}`);
        const encoded = createTextEncoder().encode(parameter);
        return { isDynamic: true, bytes: padAndLengthPrefix(encoded) }
    }

    private tryEncodeBoolean(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: false, bytes: Uint8Array } | null {
        if (description.type !== 'bool') return null;
        if (typeof parameter !== 'boolean') throw new Error(`Can only encode JavaScript 'boolean' into EVM 'bool'\n${parameter}`);
        const result = new Bytes32();
        result.set([parameter ? 1 : 0], 31);
        return { isDynamic: false, bytes: result }
    }

    private tryEncodeSmallNumber(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: false, bytes: Uint8Array } | null {
        const match = /^u?int(\d*)$/.exec(description.type);
        if (match === null) return null;
        const size = Number.parseInt(match[1]);
        if (size >= 40) return null;
        if (typeof parameter !== 'number') throw new Error(`Can only encode a JavaScript 'number' into an EVM '${description.type}'\n${parameter}`);
        return { isDynamic: false, bytes: numberToBytes32(parameter) }
    }

    private tryEncodeLargeNumber(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: false, bytes: Uint8Array } | null {
        const match = /^(u?)int(\d*)$/.exec(description.type);
        if (match === null) return null;
        const size = Number.parseInt(match[2]);
        if (size <= 32) return null;
        const signed = !match[1];
        if (!this.dependencies.isLargeInteger(parameter)) throw new Error(`Can only encode a JavaScript 'TLargeInteger' into an EVM '${description.type}'\n${parameter}`);
        return {
            isDynamic: false,
            bytes: signed ? this.dependencies.encodeLargeSignedInteger(parameter) : this.dependencies.encodeLargeUnsignedInteger(parameter)
        }
    }

    private tryEncodeAddress(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: false, bytes: Uint8Array } | null {
        if (description.type !== 'address') return null;
        if (!(parameter instanceof Uint8Array) || parameter.length !== 20) throw new Error(`Can only encode JavaScript 'Uint8Array(20)' into EVM 'address'\n${parameter}`);
        return { isDynamic: false, bytes: padLeftTo32Bytes(parameter) }
    }

    private tryEncodeFixedBytes(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: false, bytes: Uint8Array } | null {
        const match = /^bytes(\d+)$/.exec(description.type);
        if (match === null) return null;
        const size = Number.parseInt(match[1]);
        if (!(parameter instanceof Uint8Array) || parameter.length !== size) throw new Error(`Can only encode JavaScript 'Uint8Array(${size})' into EVM 'bytes${size}'\n${parameter}`);
        return { isDynamic: false, bytes: padRightTo32Bytes(parameter) }
    }

    private tryEncodeFixedPointNumber(description: ParameterDescription): { isDynamic: never, bytes: Uint8Array } | null {
        if (!/^u?fixed\d+x\d+$/.test(description.type)) return null;
        throw new Error(`Encoding into EVM type ${description.type} is not supported`)
    }

    private tryEncodeFunction(description: ParameterDescription): { isDynamic: never, bytes: Uint8Array } | null {
        if (description.type !== 'function') return null;
        throw new Error(`Encoding into EVM type ${description.type} is not supported`)
    }
}


export class Augur<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public logMarketCreated = async (topic: Bytes32, description: string, extraInfo: string, universe: Address, market: Address, marketCreator: Address, outcomes: Array<Bytes32>, minPrice: Int256<TLargeInteger>, maxPrice: Int256<TLargeInteger>, marketType: UInt8, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x07, 0xc1, 0x88, 0x0a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_topic",
            "type": "bytes32"
        }, { "name": "_description", "type": "string" }, {
            "name": "_extraInfo",
            "type": "string"
        }, { "name": "_universe", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_marketCreator", "type": "address" }, {
            "name": "_outcomes",
            "type": "bytes32[]"
        }, { "name": "_minPrice", "type": "int256" }, {
            "name": "_maxPrice",
            "type": "int256"
        }, { "name": "_marketType", "type": "uint8" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [topic, description, extraInfo, universe, market, marketCreator, outcomes, minPrice, maxPrice, marketType], { transactionName: 'logMarketCreated' })
    };

    public logMarketCreated_ = async (topic: Bytes32, description: string, extraInfo: string, universe: Address, market: Address, marketCreator: Address, outcomes: Array<Bytes32>, minPrice: Int256<TLargeInteger>, maxPrice: Int256<TLargeInteger>, marketType: UInt8, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x07, 0xc1, 0x88, 0x0a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_topic",
            "type": "bytes32"
        }, { "name": "_description", "type": "string" }, {
            "name": "_extraInfo",
            "type": "string"
        }, { "name": "_universe", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_marketCreator", "type": "address" }, {
            "name": "_outcomes",
            "type": "bytes32[]"
        }, { "name": "_minPrice", "type": "int256" }, {
            "name": "_maxPrice",
            "type": "int256"
        }, { "name": "_marketType", "type": "uint8" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [topic, description, extraInfo, universe, market, marketCreator, outcomes, minPrice, maxPrice, marketType]);
        return <boolean>result.result
    };

    public logOrderCreated = async (orderType: UInt8, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, creator: Address, moneyEscrowed: UInt256<TLargeInteger>, sharesEscrowed: UInt256<TLargeInteger>, tradeGroupId: Bytes32, orderId: Bytes32, universe: Address, shareToken: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0a, 0xe4, 0x15, 0x74]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_orderType",
            "type": "uint8"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_price", "type": "uint256" }, {
            "name": "_creator",
            "type": "address"
        }, { "name": "_moneyEscrowed", "type": "uint256" }, {
            "name": "_sharesEscrowed",
            "type": "uint256"
        }, { "name": "_tradeGroupId", "type": "bytes32" }, {
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_universe", "type": "address" }, { "name": "_shareToken", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [orderType, amount, price, creator, moneyEscrowed, sharesEscrowed, tradeGroupId, orderId, universe, shareToken], { transactionName: 'logOrderCreated' })
    };

    public logOrderCreated_ = async (orderType: UInt8, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, creator: Address, moneyEscrowed: UInt256<TLargeInteger>, sharesEscrowed: UInt256<TLargeInteger>, tradeGroupId: Bytes32, orderId: Bytes32, universe: Address, shareToken: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0a, 0xe4, 0x15, 0x74]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_orderType",
            "type": "uint8"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_price", "type": "uint256" }, {
            "name": "_creator",
            "type": "address"
        }, { "name": "_moneyEscrowed", "type": "uint256" }, {
            "name": "_sharesEscrowed",
            "type": "uint256"
        }, { "name": "_tradeGroupId", "type": "bytes32" }, {
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_universe", "type": "address" }, { "name": "_shareToken", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderType, amount, price, creator, moneyEscrowed, sharesEscrowed, tradeGroupId, orderId, universe, shareToken]);
        return <boolean>result.result
    };

    public logDisputeCrowdsourcerTokensBurned = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x10, 0x56, 0x13, 0x61]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, target, amount], { transactionName: 'logDisputeCrowdsourcerTokensBurned' })
    };

    public logDisputeCrowdsourcerTokensBurned_ = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x10, 0x56, 0x13, 0x61]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, target, amount]);
        return <boolean>result.result
    };

    public time_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x16, 0xad, 0xa5, 0x47]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public logReportingParticipantDisavowed = async (universe: Address, market: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x17, 0x57, 0x0e, 0x80]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, market], { transactionName: 'logReportingParticipantDisavowed' })
    };

    public logReportingParticipantDisavowed_ = async (universe: Address, market: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x17, 0x57, 0x0e, 0x80]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, market]);
        return <boolean>result.result
    };

    public logMarketMigrated = async (market: Address, originalUniverse: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x17, 0x67, 0x4e, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_originalUniverse", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [market, originalUniverse], { transactionName: 'logMarketMigrated' })
    };

    public logMarketMigrated_ = async (market: Address, originalUniverse: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x17, 0x67, 0x4e, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_originalUniverse", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, originalUniverse]);
        return <boolean>result.result
    };

    public getTimestamp_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x8e, 0xc3, 0x56]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public logMarketTransferred = async (universe: Address, from: Address, to: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0x29, 0x07, 0x37]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, from, to], { transactionName: 'logMarketTransferred' })
    };

    public logMarketTransferred_ = async (universe: Address, from: Address, to: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0x29, 0x07, 0x37]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, from, to]);
        return <boolean>result.result
    };

    public recordAuctionTokens = async (universe: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0x5e, 0xd3, 0x94]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_universe", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe], { transactionName: 'recordAuctionTokens' })
    };

    public recordAuctionTokens_ = async (universe: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0x5e, 0xd3, 0x94]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_universe", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe]);
        return <boolean>result.result
    };

    public logMarketFinalized = async (universe: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x27, 0x81, 0x6f, 0xfc]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_universe", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe], { transactionName: 'logMarketFinalized' })
    };

    public logMarketFinalized_ = async (universe: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x27, 0x81, 0x6f, 0xfc]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_universe", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe]);
        return <boolean>result.result
    };

    public disputeCrowdsourcerCreated = async (universe: Address, market: Address, disputeCrowdsourcer: Address, payoutNumerators: Array<UInt256<TLargeInteger>>, size: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3a, 0x22, 0x69, 0x90]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_disputeCrowdsourcer",
            "type": "address"
        }, { "name": "_payoutNumerators", "type": "uint256[]" }, { "name": "_size", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, market, disputeCrowdsourcer, payoutNumerators, size], { transactionName: 'disputeCrowdsourcerCreated' })
    };

    public disputeCrowdsourcerCreated_ = async (universe: Address, market: Address, disputeCrowdsourcer: Address, payoutNumerators: Array<UInt256<TLargeInteger>>, size: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3a, 0x22, 0x69, 0x90]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_disputeCrowdsourcer",
            "type": "address"
        }, { "name": "_payoutNumerators", "type": "uint256[]" }, { "name": "_size", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, market, disputeCrowdsourcer, payoutNumerators, size]);
        return <boolean>result.result
    };

    public logReputationTokenBurned = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x44, 0x05, 0xa3, 0x39]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, target, amount], { transactionName: 'logReputationTokenBurned' })
    };

    public logReputationTokenBurned_ = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x44, 0x05, 0xa3, 0x39]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, target, amount]);
        return <boolean>result.result
    };

    public logUniverseForked = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4a, 0x81, 0x20, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'logUniverseForked' })
    };

    public logUniverseForked_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4a, 0x81, 0x20, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public logDisputeCrowdsourcerCompleted = async (universe: Address, market: Address, disputeCrowdsourcer: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4c, 0x00, 0x19, 0xc3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_disputeCrowdsourcer", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, market, disputeCrowdsourcer], { transactionName: 'logDisputeCrowdsourcerCompleted' })
    };

    public logDisputeCrowdsourcerCompleted_ = async (universe: Address, market: Address, disputeCrowdsourcer: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4c, 0x00, 0x19, 0xc3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_disputeCrowdsourcer", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, market, disputeCrowdsourcer]);
        return <boolean>result.result
    };

    public createChildUniverse = async (parentPayoutDistributionHash: Bytes32, parentPayoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4f, 0x67, 0xaf, 0x24]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_parentPayoutDistributionHash",
            "type": "bytes32"
        }, { "name": "_parentPayoutNumerators", "type": "uint256[]" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [parentPayoutDistributionHash, parentPayoutNumerators], { transactionName: 'createChildUniverse' })
    };

    public createChildUniverse_ = async (parentPayoutDistributionHash: Bytes32, parentPayoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4f, 0x67, 0xaf, 0x24]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_parentPayoutDistributionHash",
            "type": "bytes32"
        }, { "name": "_parentPayoutNumerators", "type": "uint256[]" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [parentPayoutDistributionHash, parentPayoutNumerators]);
        return <Address>result.result
    };

    public logDisputeCrowdsourcerTokensTransferred = async (universe: Address, from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x50, 0xbd, 0x5c, 0xb9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, {
            "name": "_value",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, from, to, value], { transactionName: 'logDisputeCrowdsourcerTokensTransferred' })
    };

    public logDisputeCrowdsourcerTokensTransferred_ = async (universe: Address, from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x50, 0xbd, 0x5c, 0xb9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, {
            "name": "_value",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, from, to, value]);
        return <boolean>result.result
    };

    public isKnownFeeSender_ = async (feeSender: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x58, 0x97, 0xe6, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_feeSender", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [feeSender]);
        return <boolean>result.result
    };

    public isValidMarket_ = async (market: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x58, 0xe6, 0x30, 0x9f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_market", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market]);
        return <boolean>result.result
    };

    public logDisputeCrowdsourcerContribution = async (universe: Address, reporter: Address, market: Address, disputeCrowdsourcer: Address, amountStaked: UInt256<TLargeInteger>, description: string, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5f, 0x87, 0x21, 0x47]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_reporter", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_disputeCrowdsourcer", "type": "address" }, {
            "name": "_amountStaked",
            "type": "uint256"
        }, { "name": "_description", "type": "string" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, reporter, market, disputeCrowdsourcer, amountStaked, description], { transactionName: 'logDisputeCrowdsourcerContribution' })
    };

    public logDisputeCrowdsourcerContribution_ = async (universe: Address, reporter: Address, market: Address, disputeCrowdsourcer: Address, amountStaked: UInt256<TLargeInteger>, description: string, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5f, 0x87, 0x21, 0x47]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_reporter", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_disputeCrowdsourcer", "type": "address" }, {
            "name": "_amountStaked",
            "type": "uint256"
        }, { "name": "_description", "type": "string" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, reporter, market, disputeCrowdsourcer, amountStaked, description]);
        return <boolean>result.result
    };

    public logTradingProceedsClaimed = async (universe: Address, shareToken: Address, sender: Address, market: Address, numShares: UInt256<TLargeInteger>, numPayoutTokens: UInt256<TLargeInteger>, finalTokenBalance: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x60, 0x51, 0xfa, 0x2c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_shareToken", "type": "address" }, { "name": "_sender", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_numShares", "type": "uint256" }, {
            "name": "_numPayoutTokens",
            "type": "uint256"
        }, { "name": "_finalTokenBalance", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, shareToken, sender, market, numShares, numPayoutTokens, finalTokenBalance], { transactionName: 'logTradingProceedsClaimed' })
    };

    public logTradingProceedsClaimed_ = async (universe: Address, shareToken: Address, sender: Address, market: Address, numShares: UInt256<TLargeInteger>, numPayoutTokens: UInt256<TLargeInteger>, finalTokenBalance: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x60, 0x51, 0xfa, 0x2c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_shareToken", "type": "address" }, { "name": "_sender", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_numShares", "type": "uint256" }, {
            "name": "_numPayoutTokens",
            "type": "uint256"
        }, { "name": "_finalTokenBalance", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, shareToken, sender, market, numShares, numPayoutTokens, finalTokenBalance]);
        return <boolean>result.result
    };

    public registerContract = async (key: Bytes32, address: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x64, 0x5c, 0x6f, 0xae]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_key",
            "type": "bytes32"
        }, { "name": "_address", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [key, address], { transactionName: 'registerContract' })
    };

    public registerContract_ = async (key: Bytes32, address: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x64, 0x5c, 0x6f, 0xae]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_key",
            "type": "bytes32"
        }, { "name": "_address", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [key, address]);
        return <boolean>result.result
    };

    public uploader_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x65, 0xfe, 0x2a, 0x0b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public logOrderCanceled = async (universe: Address, shareToken: Address, sender: Address, orderId: Bytes32, orderType: UInt8, tokenRefund: UInt256<TLargeInteger>, sharesRefund: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6e, 0x16, 0x36, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_shareToken", "type": "address" }, { "name": "_sender", "type": "address" }, {
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_orderType", "type": "uint8" }, {
            "name": "_tokenRefund",
            "type": "uint256"
        }, { "name": "_sharesRefund", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, shareToken, sender, orderId, orderType, tokenRefund, sharesRefund], { transactionName: 'logOrderCanceled' })
    };

    public logOrderCanceled_ = async (universe: Address, shareToken: Address, sender: Address, orderId: Bytes32, orderType: UInt8, tokenRefund: UInt256<TLargeInteger>, sharesRefund: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6e, 0x16, 0x36, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_shareToken", "type": "address" }, { "name": "_sender", "type": "address" }, {
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_orderType", "type": "uint8" }, {
            "name": "_tokenRefund",
            "type": "uint256"
        }, { "name": "_sharesRefund", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, shareToken, sender, orderId, orderType, tokenRefund, sharesRefund]);
        return <boolean>result.result
    };

    public logReputationTokenMinted = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x79, 0xff, 0xf7, 0xa9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, target, amount], { transactionName: 'logReputationTokenMinted' })
    };

    public logReputationTokenMinted_ = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x79, 0xff, 0xf7, 0xa9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, target, amount]);
        return <boolean>result.result
    };

    public registry_ = async (arg0: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7e, 0xf5, 0x02, 0x98]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [arg0]);
        return <Address>result.result
    };

    public logDisputeCrowdsourcerRedeemed = async (universe: Address, reporter: Address, market: Address, amountRedeemed: UInt256<TLargeInteger>, repReceived: UInt256<TLargeInteger>, payoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x80, 0x67, 0x5f, 0xdc]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_reporter", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_amountRedeemed", "type": "uint256" }, {
            "name": "_repReceived",
            "type": "uint256"
        }, { "name": "_payoutNumerators", "type": "uint256[]" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, reporter, market, amountRedeemed, repReceived, payoutNumerators], { transactionName: 'logDisputeCrowdsourcerRedeemed' })
    };

    public logDisputeCrowdsourcerRedeemed_ = async (universe: Address, reporter: Address, market: Address, amountRedeemed: UInt256<TLargeInteger>, repReceived: UInt256<TLargeInteger>, payoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x80, 0x67, 0x5f, 0xdc]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_reporter", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_amountRedeemed", "type": "uint256" }, {
            "name": "_repReceived",
            "type": "uint256"
        }, { "name": "_payoutNumerators", "type": "uint256[]" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, reporter, market, amountRedeemed, repReceived, payoutNumerators]);
        return <boolean>result.result
    };

    public logOrderFilled = async (universe: Address, shareToken: Address, filler: Address, orderId: Bytes32, numCreatorShares: UInt256<TLargeInteger>, numCreatorTokens: UInt256<TLargeInteger>, numFillerShares: UInt256<TLargeInteger>, numFillerTokens: UInt256<TLargeInteger>, marketCreatorFees: UInt256<TLargeInteger>, reporterFees: UInt256<TLargeInteger>, amountFilled: UInt256<TLargeInteger>, tradeGroupId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x80, 0xd5, 0x39, 0x8e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_shareToken", "type": "address" }, { "name": "_filler", "type": "address" }, {
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_numCreatorShares", "type": "uint256" }, {
            "name": "_numCreatorTokens",
            "type": "uint256"
        }, { "name": "_numFillerShares", "type": "uint256" }, {
            "name": "_numFillerTokens",
            "type": "uint256"
        }, { "name": "_marketCreatorFees", "type": "uint256" }, {
            "name": "_reporterFees",
            "type": "uint256"
        }, { "name": "_amountFilled", "type": "uint256" }, { "name": "_tradeGroupId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, shareToken, filler, orderId, numCreatorShares, numCreatorTokens, numFillerShares, numFillerTokens, marketCreatorFees, reporterFees, amountFilled, tradeGroupId], { transactionName: 'logOrderFilled' })
    };

    public logOrderFilled_ = async (universe: Address, shareToken: Address, filler: Address, orderId: Bytes32, numCreatorShares: UInt256<TLargeInteger>, numCreatorTokens: UInt256<TLargeInteger>, numFillerShares: UInt256<TLargeInteger>, numFillerTokens: UInt256<TLargeInteger>, marketCreatorFees: UInt256<TLargeInteger>, reporterFees: UInt256<TLargeInteger>, amountFilled: UInt256<TLargeInteger>, tradeGroupId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x80, 0xd5, 0x39, 0x8e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_shareToken", "type": "address" }, { "name": "_filler", "type": "address" }, {
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_numCreatorShares", "type": "uint256" }, {
            "name": "_numCreatorTokens",
            "type": "uint256"
        }, { "name": "_numFillerShares", "type": "uint256" }, {
            "name": "_numFillerTokens",
            "type": "uint256"
        }, { "name": "_marketCreatorFees", "type": "uint256" }, {
            "name": "_reporterFees",
            "type": "uint256"
        }, { "name": "_amountFilled", "type": "uint256" }, { "name": "_tradeGroupId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, shareToken, filler, orderId, numCreatorShares, numCreatorTokens, numFillerShares, numFillerTokens, marketCreatorFees, reporterFees, amountFilled, tradeGroupId]);
        return <boolean>result.result
    };

    public isKnownShareToken_ = async (token: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0xe7, 0x9d, 0xa8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_token", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [token]);
        return <boolean>result.result
    };

    public logShareTokensTransferred = async (universe: Address, from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x86, 0xb9, 0xa1, 0xf4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, {
            "name": "_value",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, from, to, value], { transactionName: 'logShareTokensTransferred' })
    };

    public logShareTokensTransferred_ = async (universe: Address, from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x86, 0xb9, 0xa1, 0xf4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, {
            "name": "_value",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, from, to, value]);
        return <boolean>result.result
    };

    public isKnownUniverse_ = async (universe: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8c, 0xfb, 0x8f, 0x21]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_universe", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe]);
        return <boolean>result.result
    };

    public logInitialReportSubmitted = async (universe: Address, reporter: Address, market: Address, amountStaked: UInt256<TLargeInteger>, isDesignatedReporter: boolean, payoutNumerators: Array<UInt256<TLargeInteger>>, description: string, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x93, 0xc7, 0x47, 0x83]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_reporter", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_amountStaked", "type": "uint256" }, {
            "name": "_isDesignatedReporter",
            "type": "bool"
        }, { "name": "_payoutNumerators", "type": "uint256[]" }, { "name": "_description", "type": "string" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, reporter, market, amountStaked, isDesignatedReporter, payoutNumerators, description], { transactionName: 'logInitialReportSubmitted' })
    };

    public logInitialReportSubmitted_ = async (universe: Address, reporter: Address, market: Address, amountStaked: UInt256<TLargeInteger>, isDesignatedReporter: boolean, payoutNumerators: Array<UInt256<TLargeInteger>>, description: string, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x93, 0xc7, 0x47, 0x83]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_reporter", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_amountStaked", "type": "uint256" }, {
            "name": "_isDesignatedReporter",
            "type": "bool"
        }, { "name": "_payoutNumerators", "type": "uint256[]" }, { "name": "_description", "type": "string" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, reporter, market, amountStaked, isDesignatedReporter, payoutNumerators, description]);
        return <boolean>result.result
    };

    public createGenesisUniverse = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x96, 0x84, 0xda, 0x1a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'createGenesisUniverse' })
    };

    public createGenesisUniverse_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x96, 0x84, 0xda, 0x1a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public logAuctionTokensTransferred = async (universe: Address, from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9b, 0x07, 0x63, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, {
            "name": "_value",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, from, to, value], { transactionName: 'logAuctionTokensTransferred' })
    };

    public logAuctionTokensTransferred_ = async (universe: Address, from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9b, 0x07, 0x63, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, {
            "name": "_value",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, from, to, value]);
        return <boolean>result.result
    };

    public logDisputeWindowCreated = async (disputeWindow: Address, id: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9c, 0xb0, 0x39, 0xb6]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_disputeWindow",
            "type": "address"
        }, { "name": "_id", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [disputeWindow, id], { transactionName: 'logDisputeWindowCreated' })
    };

    public logDisputeWindowCreated_ = async (disputeWindow: Address, id: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9c, 0xb0, 0x39, 0xb6]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_disputeWindow",
            "type": "address"
        }, { "name": "_id", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [disputeWindow, id]);
        return <boolean>result.result
    };

    public logShareTokenBurned = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa1, 0xb7, 0x88, 0x7f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, target, amount], { transactionName: 'logShareTokenBurned' })
    };

    public logShareTokenBurned_ = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa1, 0xb7, 0x88, 0x7f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, target, amount]);
        return <boolean>result.result
    };

    public logShareTokenMinted = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa1, 0xdf, 0xe5, 0x45]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, target, amount], { transactionName: 'logShareTokenMinted' })
    };

    public logShareTokenMinted_ = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa1, 0xdf, 0xe5, 0x45]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, target, amount]);
        return <boolean>result.result
    };

    public logDisputeCrowdsourcerTokensMinted = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x48, 0x23, 0xe1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, target, amount], { transactionName: 'logDisputeCrowdsourcerTokensMinted' })
    };

    public logDisputeCrowdsourcerTokensMinted_ = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x48, 0x23, 0xe1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, target, amount]);
        return <boolean>result.result
    };

    public logInitialReporterRedeemed = async (universe: Address, reporter: Address, market: Address, amountRedeemed: UInt256<TLargeInteger>, repReceived: UInt256<TLargeInteger>, payoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0xc0, 0x94, 0xfa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_reporter", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_amountRedeemed", "type": "uint256" }, {
            "name": "_repReceived",
            "type": "uint256"
        }, { "name": "_payoutNumerators", "type": "uint256[]" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, reporter, market, amountRedeemed, repReceived, payoutNumerators], { transactionName: 'logInitialReporterRedeemed' })
    };

    public logInitialReporterRedeemed_ = async (universe: Address, reporter: Address, market: Address, amountRedeemed: UInt256<TLargeInteger>, repReceived: UInt256<TLargeInteger>, payoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0xc0, 0x94, 0xfa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_reporter", "type": "address" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_amountRedeemed", "type": "uint256" }, {
            "name": "_repReceived",
            "type": "uint256"
        }, { "name": "_payoutNumerators", "type": "uint256[]" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, reporter, market, amountRedeemed, repReceived, payoutNumerators]);
        return <boolean>result.result
    };

    public isKnownCrowdsourcer_ = async (crowdsourcer: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb7, 0x0d, 0xa7, 0xdc]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_crowdsourcer", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [crowdsourcer]);
        return <boolean>result.result
    };

    public isKnownAuctionToken_ = async (token: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb9, 0x66, 0x56, 0xb0]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_token", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [token]);
        return <boolean>result.result
    };

    public logCompleteSetsPurchased = async (universe: Address, market: Address, account: Address, numCompleteSets: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc5, 0x09, 0xd0, 0xb2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_account",
            "type": "address"
        }, { "name": "_numCompleteSets", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, market, account, numCompleteSets], { transactionName: 'logCompleteSetsPurchased' })
    };

    public logCompleteSetsPurchased_ = async (universe: Address, market: Address, account: Address, numCompleteSets: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc5, 0x09, 0xd0, 0xb2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_account",
            "type": "address"
        }, { "name": "_numCompleteSets", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, market, account, numCompleteSets]);
        return <boolean>result.result
    };

    public logMarketParticipantsDisavowed = async (universe: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc6, 0x7a, 0xf5, 0xcc]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_universe", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe], { transactionName: 'logMarketParticipantsDisavowed' })
    };

    public logMarketParticipantsDisavowed_ = async (universe: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc6, 0x7a, 0xf5, 0xcc]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_universe", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe]);
        return <boolean>result.result
    };

    public logTimestampSet = async (newTimestamp: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc8, 0xe6, 0xb2, 0xa8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newTimestamp", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [newTimestamp], { transactionName: 'logTimestampSet' })
    };

    public logTimestampSet_ = async (newTimestamp: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc8, 0xe6, 0xb2, 0xa8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newTimestamp", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [newTimestamp]);
        return <boolean>result.result
    };

    public logAuctionTokenBurned = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd5, 0x30, 0xa0, 0x5a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, target, amount], { transactionName: 'logAuctionTokenBurned' })
    };

    public logAuctionTokenBurned_ = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd5, 0x30, 0xa0, 0x5a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, target, amount]);
        return <boolean>result.result
    };

    public logInitialReporterTransferred = async (universe: Address, market: Address, from: Address, to: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe3, 0x14, 0x2e, 0x90]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_from", "type": "address" }, {
            "name": "_to",
            "type": "address"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, market, from, to], { transactionName: 'logInitialReporterTransferred' })
    };

    public logInitialReporterTransferred_ = async (universe: Address, market: Address, from: Address, to: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe3, 0x14, 0x2e, 0x90]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_from", "type": "address" }, {
            "name": "_to",
            "type": "address"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, market, from, to]);
        return <boolean>result.result
    };

    public finishDeployment = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe9, 0x97, 0xff, 0xfd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'finishDeployment' })
    };

    public finishDeployment_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe9, 0x97, 0xff, 0xfd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public trustedTransfer = async (token: Address, from: Address, to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xec, 0x23, 0x89, 0x94]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_token",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, {
            "name": "_amount",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [token, from, to, amount], { transactionName: 'trustedTransfer' })
    };

    public trustedTransfer_ = async (token: Address, from: Address, to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xec, 0x23, 0x89, 0x94]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_token",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, {
            "name": "_amount",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [token, from, to, amount]);
        return <boolean>result.result
    };

    public logReputationTokensTransferred = async (universe: Address, from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xec, 0x37, 0xa6, 0xe4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, {
            "name": "_value",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, from, to, value], { transactionName: 'logReputationTokensTransferred' })
    };

    public logReputationTokensTransferred_ = async (universe: Address, from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xec, 0x37, 0xa6, 0xe4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, {
            "name": "_value",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, from, to, value]);
        return <boolean>result.result
    };

    public logAuctionTokenMinted = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xec, 0xec, 0xa9, 0x56]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, target, amount], { transactionName: 'logAuctionTokenMinted' })
    };

    public logAuctionTokenMinted_ = async (universe: Address, target: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xec, 0xec, 0xa9, 0x56]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_target", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, target, amount]);
        return <boolean>result.result
    };

    public logCompleteSetsSold = async (universe: Address, market: Address, account: Address, numCompleteSets: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xed, 0x65, 0x4f, 0xd7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_account",
            "type": "address"
        }, { "name": "_numCompleteSets", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe, market, account, numCompleteSets], { transactionName: 'logCompleteSetsSold' })
    };

    public logCompleteSetsSold_ = async (universe: Address, market: Address, account: Address, numCompleteSets: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xed, 0x65, 0x4f, 0xd7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_universe",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_account",
            "type": "address"
        }, { "name": "_numCompleteSets", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe, market, account, numCompleteSets]);
        return <boolean>result.result
    };

    public lookup_ = async (key: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf3, 0x9e, 0xc1, 0xf7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_key", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [key]);
        return <Address>result.result
	}
}


export class ERC820Registry<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public setInterfaceImplementer = async (addr: Address, iHash: Bytes32, implementer: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x29, 0x96, 0x5a, 0x1d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "addr",
            "type": "address"
        }, { "name": "iHash", "type": "bytes32" }, { "name": "implementer", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [addr, iHash, implementer], { transactionName: 'setInterfaceImplementer' })
    };

    public setInterfaceImplementer_ = async (addr: Address, iHash: Bytes32, implementer: Address, options?: {}): Promise<void> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x29, 0x96, 0x5a, 0x1d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "addr",
            "type": "address"
        }, { "name": "iHash", "type": "bytes32" }, { "name": "implementer", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [];
        await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [addr, iHash, implementer])
    };

    public getManager_ = async (addr: Address, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3d, 0x58, 0x40, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "addr", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [addr]);
        return <Address>result.result
    };

    public erc165UpdateCache = async (contract: Address, interfaceId: Bytes4, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x57, 0x1a, 0x1f, 0x66]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_contract",
            "type": "address"
        }, { "name": "_interfaceId", "type": "bytes4" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [contract, interfaceId], { transactionName: 'erc165UpdateCache' })
    };

    public erc165UpdateCache_ = async (contract: Address, interfaceId: Bytes4, options?: {}): Promise<void> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x57, 0x1a, 0x1f, 0x66]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_contract",
            "type": "address"
        }, { "name": "_interfaceId", "type": "bytes4" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [];
        await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [contract, interfaceId])
    };

    public setManager = async (addr: Address, newManager: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5d, 0xf8, 0x12, 0x2f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "addr",
            "type": "address"
        }, { "name": "newManager", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [addr, newManager], { transactionName: 'setManager' })
    };

    public setManager_ = async (addr: Address, newManager: Address, options?: {}): Promise<void> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5d, 0xf8, 0x12, 0x2f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "addr",
            "type": "address"
        }, { "name": "newManager", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [];
        await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [addr, newManager])
    };

    public interfaceHash_ = async (interfaceName: string, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x65, 0xba, 0x36, 0xc1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "interfaceName", "type": "string" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [interfaceName]);
        return <Bytes32>result.result
    };

    public erc165InterfaceSupported = async (contract: Address, interfaceId: Bytes4, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x90, 0xe4, 0x79, 0x57]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_contract",
            "type": "address"
        }, { "name": "_interfaceId", "type": "bytes4" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [contract, interfaceId], { transactionName: 'erc165InterfaceSupported' })
    };

    public erc165InterfaceSupported_ = async (contract: Address, interfaceId: Bytes4, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x90, 0xe4, 0x79, 0x57]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_contract",
            "type": "address"
        }, { "name": "_interfaceId", "type": "bytes4" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [contract, interfaceId]);
        return <boolean>result.result
    };

    public getInterfaceImplementer = async (addr: Address, iHash: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xaa, 0xbb, 0xb8, 0xca]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "addr",
            "type": "address"
        }, { "name": "iHash", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [addr, iHash], { transactionName: 'getInterfaceImplementer' })
    };

    public getInterfaceImplementer_ = async (addr: Address, iHash: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xaa, 0xbb, 0xb8, 0xca]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "addr",
            "type": "address"
        }, { "name": "iHash", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [addr, iHash]);
        return <Address>result.result
    };

    public erc165InterfaceSupported_NoCache_ = async (contract: Address, interfaceId: Bytes4, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdd, 0xc2, 0x3d, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_contract",
            "type": "address"
        }, { "name": "_interfaceId", "type": "bytes4" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [contract, interfaceId]);
        return <boolean>result.result
	}
}


export class LegacyReputationToken<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public supply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x04, 0x7f, 0xc9, 0xaa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public defaultOperators_ = async (options?: {}): Promise<Array<Address>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xe4, 0x85, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address[]" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Array<Address>>result.result
    };

    public name_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xfd, 0xde, 0x03]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public approve = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, amount], { transactionName: 'approve' })
    };

    public approve_ = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, amount]);
        return <boolean>result.result
    };

    public totalSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x16, 0x0d, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getTimestamp_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x8e, 0xc3, 0x56]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getTotalTheoreticalSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0x8d, 0x35, 0x90]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public transferFrom = async (from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, value], { transactionName: 'transferFrom' })
    };

    public transferFrom_ = async (from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, value]);
        return <boolean>result.result
    };

    public decimals_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x31, 0x3c, 0xe5, 0x67]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public granularity_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x55, 0x6f, 0x0d, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public faucet = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x57, 0x91, 0x58, 0x97]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amount], { transactionName: 'faucet' })
    };

    public faucet_ = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x57, 0x91, 0x58, 0x97]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amount]);
        return <boolean>result.result
    };

    public migrateOutByPayout = async (payoutNumerators: Array<UInt256<TLargeInteger>>, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0x66, 0x87, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [payoutNumerators, attotokens], { transactionName: 'migrateOutByPayout' })
    };

    public migrateOutByPayout_ = async (payoutNumerators: Array<UInt256<TLargeInteger>>, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0x66, 0x87, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [payoutNumerators, attotokens]);
        return <boolean>result.result
    };

    public ETERNAL_APPROVAL_VALUE_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x63, 0x4e, 0xaf, 0xf1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public decreaseApproval = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, subtractedValue], { transactionName: 'decreaseApproval' })
    };

    public decreaseApproval_ = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, subtractedValue]);
        return <boolean>result.result
    };

    public migrateOut = async (destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6e, 0x7c, 0xe5, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_destination",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [destination, attotokens], { transactionName: 'migrateOut' })
    };

    public migrateOut_ = async (destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6e, 0x7c, 0xe5, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_destination",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [destination, attotokens]);
        return <boolean>result.result
    };

    public balanceOf_ = async (tokenHolder: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x70, 0xa0, 0x82, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [tokenHolder]);
        return <UInt256<TLargeInteger>>result.result
    };

    public trustedDisputeWindowTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x72, 0x1b, 0xb1, 0x70]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedDisputeWindowTransfer' })
    };

    public trustedDisputeWindowTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x72, 0x1b, 0xb1, 0x70]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public getLegacyRepToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x77, 0x46, 0x92, 0x75]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getIsMigratingFromLegacy_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7c, 0xf9, 0x9c, 0x33]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public migrateBalancesFromLegacyRep = async (holders: Array<Address>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7f, 0x68, 0x62, 0x59]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_holders", "type": "address[]" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [holders], { transactionName: 'migrateBalancesFromLegacyRep' })
    };

    public migrateBalancesFromLegacyRep_ = async (holders: Array<Address>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7f, 0x68, 0x62, 0x59]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_holders", "type": "address[]" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [holders]);
        return <boolean>result.result
    };

    public sendNoHooks = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'sendNoHooks' })
    };

    public sendNoHooks_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public getUniverse_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x87, 0x0c, 0x42, 0x6d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getTotalMigrated_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x91, 0xd7, 0x6b, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public authorizeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'authorizeOperator' })
    };

    public authorizeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public symbol_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xd8, 0x9b, 0x41]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public erc820Registry_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x2a, 0x14, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public migrateIn = async (reporter: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa0, 0xc1, 0xca, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_reporter",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [reporter, attotokens], { transactionName: 'migrateIn' })
    };

    public migrateIn_ = async (reporter: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa0, 0xc1, 0xca, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_reporter",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [reporter, attotokens]);
        return <boolean>result.result
    };

    public updateParentTotalTheoreticalSupply = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa8, 0x19, 0x51, 0x5d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'updateParentTotalTheoreticalSupply' })
    };

    public updateParentTotalTheoreticalSupply_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa8, 0x19, 0x51, 0x5d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public transfer = async (to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_value", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, value], { transactionName: 'transfer' })
    };

    public transfer_ = async (to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_value", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, value]);
        return <boolean>result.result
    };

    public send = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'send' })
    };

    public send_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public trustedReportingParticipantTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x73, 0xe9, 0xa7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedReportingParticipantTransfer' })
    };

    public trustedReportingParticipantTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x73, 0xe9, 0xa7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public controllerLookupName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbe, 0xf7, 0x2f, 0xa2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public initialize = async (universe: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_universe", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [universe], { transactionName: 'initialize' })
    };

    public initialize_ = async (universe: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_universe", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [universe]);
        return <boolean>result.result
    };

    public increaseApproval = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, addedValue], { transactionName: 'increaseApproval' })
    };

    public increaseApproval_ = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, addedValue]);
        return <boolean>result.result
    };

    public isOperatorFor_ = async (operator: Address, tokenHolder: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0x5b, 0x63, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_operator",
            "type": "address"
        }, { "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator, tokenHolder]);
        return <boolean>result.result
    };

    public updateSiblingMigrationTotal = async (token: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0xd3, 0xe0, 0x7d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_token", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [token], { transactionName: 'updateSiblingMigrationTotal' })
    };

    public updateSiblingMigrationTotal_ = async (token: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0xd3, 0xe0, 0x7d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_token", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [token]);
        return <boolean>result.result
    };

    public mintForReportingParticipant = async (amountMigrated: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x05, 0x41, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_amountMigrated",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amountMigrated], { transactionName: 'mintForReportingParticipant' })
    };

    public mintForReportingParticipant_ = async (amountMigrated: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x05, 0x41, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_amountMigrated",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amountMigrated]);
        return <boolean>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public operatorSend = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount, data, operatorData], { transactionName: 'operatorSend' })
    };

    public operatorSend_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount, data, operatorData]);
        return <boolean>result.result
    };

    public allowance_ = async (owner: Address, spender: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdd, 0x62, 0xed, 0x3e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_spender", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owner, spender]);
        return <UInt256<TLargeInteger>>result.result
    };

    public migrateAllowancesFromLegacyRep = async (owners: Array<Address>, spenders: Array<Address>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xde, 0x4c, 0x05, 0x74]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owners",
            "type": "address[]"
        }, { "name": "_spenders", "type": "address[]" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [owners, spenders], { transactionName: 'migrateAllowancesFromLegacyRep' })
    };

    public migrateAllowancesFromLegacyRep_ = async (owners: Array<Address>, spenders: Array<Address>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xde, 0x4c, 0x05, 0x74]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owners",
            "type": "address[]"
        }, { "name": "_spenders", "type": "address[]" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owners, spenders]);
        return <boolean>result.result
    };

    public getTargetSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xde, 0xa6, 0xae, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public trustedMarketTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0x2b, 0x25, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedMarketTransfer' })
    };

    public trustedMarketTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0x2b, 0x25, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public initializeERC820 = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf7, 0xd1, 0xd8, 0x94]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initializeERC820' })
    };

    public initializeERC820_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf7, 0xd1, 0xd8, 0x94]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public revokeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'revokeOperator' })
    };

    public revokeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public trustedUniverseTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfe, 0x98, 0x18, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedUniverseTransfer' })
    };

    public trustedUniverseTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfe, 0x98, 0x18, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
	}
}


export class TestNetReputationToken<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public supply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x04, 0x7f, 0xc9, 0xaa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public defaultOperators_ = async (options?: {}): Promise<Array<Address>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xe4, 0x85, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address[]" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Array<Address>>result.result
    };

    public name_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xfd, 0xde, 0x03]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public approve = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, amount], { transactionName: 'approve' })
    };

    public approve_ = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, amount]);
        return <boolean>result.result
    };

    public totalSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x16, 0x0d, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getTotalTheoreticalSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0x8d, 0x35, 0x90]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public transferFrom = async (from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, value], { transactionName: 'transferFrom' })
    };

    public transferFrom_ = async (from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, value]);
        return <boolean>result.result
    };

    public decimals_ = async (options?: {}): Promise<UInt8> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x31, 0x3c, 0xe5, 0x67]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint8" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt8>result.result
    };

    public granularity_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x55, 0x6f, 0x0d, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public faucet = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x57, 0x91, 0x58, 0x97]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amount], { transactionName: 'faucet' })
    };

    public faucet_ = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x57, 0x91, 0x58, 0x97]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amount]);
        return <boolean>result.result
    };

    public migrateOutByPayout = async (payoutNumerators: Array<UInt256<TLargeInteger>>, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0x66, 0x87, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [payoutNumerators, attotokens], { transactionName: 'migrateOutByPayout' })
    };

    public migrateOutByPayout_ = async (payoutNumerators: Array<UInt256<TLargeInteger>>, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0x66, 0x87, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [payoutNumerators, attotokens]);
        return <boolean>result.result
    };

    public burnForAuction = async (amountToBurn: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x60, 0x17, 0x41, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToBurn", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amountToBurn], { transactionName: 'burnForAuction' })
    };

    public burnForAuction_ = async (amountToBurn: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x60, 0x17, 0x41, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToBurn", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amountToBurn]);
        return <boolean>result.result
    };

    public ETERNAL_APPROVAL_VALUE_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x63, 0x4e, 0xaf, 0xf1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public decreaseApproval = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, subtractedValue], { transactionName: 'decreaseApproval' })
    };

    public decreaseApproval_ = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, subtractedValue]);
        return <boolean>result.result
    };

    public migrateOut = async (destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6e, 0x7c, 0xe5, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_destination",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [destination, attotokens], { transactionName: 'migrateOut' })
    };

    public migrateOut_ = async (destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6e, 0x7c, 0xe5, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_destination",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [destination, attotokens]);
        return <boolean>result.result
    };

    public balanceOf_ = async (tokenHolder: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x70, 0xa0, 0x82, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [tokenHolder]);
        return <UInt256<TLargeInteger>>result.result
    };

    public migrateFromLegacyReputationToken = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x75, 0xd9, 0xaa, 0x1a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'migrateFromLegacyReputationToken' })
    };

    public migrateFromLegacyReputationToken_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x75, 0xd9, 0xaa, 0x1a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getLegacyRepToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x77, 0x46, 0x92, 0x75]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public sendNoHooks = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'sendNoHooks' })
    };

    public sendNoHooks_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public getUniverse_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x87, 0x0c, 0x42, 0x6d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getTotalMigrated_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x91, 0xd7, 0x6b, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public authorizeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'authorizeOperator' })
    };

    public authorizeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public symbol_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xd8, 0x9b, 0x41]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public trustedAuctionTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x97, 0xfa, 0x56, 0xc1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedAuctionTransfer' })
    };

    public trustedAuctionTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x97, 0xfa, 0x56, 0xc1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public erc820Registry_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x2a, 0x14, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public migrateIn = async (reporter: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa0, 0xc1, 0xca, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_reporter",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [reporter, attotokens], { transactionName: 'migrateIn' })
    };

    public migrateIn_ = async (reporter: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa0, 0xc1, 0xca, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_reporter",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [reporter, attotokens]);
        return <boolean>result.result
    };

    public transfer = async (to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_value", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, value], { transactionName: 'transfer' })
    };

    public transfer_ = async (to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_value", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, value]);
        return <boolean>result.result
    };

    public burnForMarket = async (amountToBurn: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xae, 0x38, 0x16, 0xee]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToBurn", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amountToBurn], { transactionName: 'burnForMarket' })
    };

    public burnForMarket_ = async (amountToBurn: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xae, 0x38, 0x16, 0xee]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToBurn", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amountToBurn]);
        return <boolean>result.result
    };

    public send = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'send' })
    };

    public send_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public trustedReportingParticipantTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x73, 0xe9, 0xa7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedReportingParticipantTransfer' })
    };

    public trustedReportingParticipantTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x73, 0xe9, 0xa7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public mintForAuction = async (amountToMint: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbb, 0x05, 0xc7, 0x06]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToMint", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amountToMint], { transactionName: 'mintForAuction' })
    };

    public mintForAuction_ = async (amountToMint: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbb, 0x05, 0xc7, 0x06]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToMint", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amountToMint]);
        return <boolean>result.result
    };

    public legacyRepToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd5, 0x46, 0x67, 0x77]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public increaseApproval = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, addedValue], { transactionName: 'increaseApproval' })
    };

    public increaseApproval_ = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, addedValue]);
        return <boolean>result.result
    };

    public isOperatorFor_ = async (operator: Address, tokenHolder: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0x5b, 0x63, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_operator",
            "type": "address"
        }, { "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator, tokenHolder]);
        return <boolean>result.result
    };

    public updateTotalTheoreticalSupply = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xda, 0xcf, 0xed, 0xab]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'updateTotalTheoreticalSupply' })
    };

    public updateTotalTheoreticalSupply_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xda, 0xcf, 0xed, 0xab]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public mintForReportingParticipant = async (amountMigrated: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x05, 0x41, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_amountMigrated",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amountMigrated], { transactionName: 'mintForReportingParticipant' })
    };

    public mintForReportingParticipant_ = async (amountMigrated: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x05, 0x41, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_amountMigrated",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amountMigrated]);
        return <boolean>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public operatorSend = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount, data, operatorData], { transactionName: 'operatorSend' })
    };

    public operatorSend_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount, data, operatorData]);
        return <boolean>result.result
    };

    public allowance_ = async (owner: Address, spender: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdd, 0x62, 0xed, 0x3e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_spender", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owner, spender]);
        return <UInt256<TLargeInteger>>result.result
    };

    public trustedMarketTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0x2b, 0x25, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedMarketTransfer' })
    };

    public trustedMarketTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0x2b, 0x25, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public revokeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'revokeOperator' })
    };

    public revokeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public trustedUniverseTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfe, 0x98, 0x18, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedUniverseTransfer' })
    };

    public trustedUniverseTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfe, 0x98, 0x18, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
	}
}


export class TestOrders<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public testRecordFillOrder = async (orderId: Bytes32, sharesFilled: UInt256<TLargeInteger>, tokensFilled: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0d, 0x3a, 0x6d, 0xfd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_sharesFilled", "type": "uint256" }, { "name": "_tokensFilled", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [orderId, sharesFilled, tokensFilled], { transactionName: 'testRecordFillOrder' })
    };

    public testRecordFillOrder_ = async (orderId: Bytes32, sharesFilled: UInt256<TLargeInteger>, tokensFilled: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0d, 0x3a, 0x6d, 0xfd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_sharesFilled", "type": "uint256" }, { "name": "_tokensFilled", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId, sharesFilled, tokensFilled]);
        return <boolean>result.result
    };

    public getAmount_ = async (orderId: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0e, 0x0a, 0x0d, 0x74]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt256<TLargeInteger>>result.result
    };

    public descendOrderList_ = async (type: UInt8, price: UInt256<TLargeInteger>, highestOrderId: Bytes32, options?: {}): Promise<{ _betterOrderId: Bytes32, _worseOrderId: Bytes32 }> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0e, 0x14, 0x24, 0xb5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_highestOrderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, highestOrderId]);
        return <{ _betterOrderId: Bytes32, _worseOrderId: Bytes32 }>result
    };

    public getOrderId_ = async (type: UInt8, market: Address, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, sender: Address, blockNumber: UInt256<TLargeInteger>, outcome: UInt256<TLargeInteger>, moneyEscrowed: UInt256<TLargeInteger>, sharesEscrowed: UInt256<TLargeInteger>, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x17, 0x27, 0x58, 0x3c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_price",
            "type": "uint256"
        }, { "name": "_sender", "type": "address" }, {
            "name": "_blockNumber",
            "type": "uint256"
        }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_moneyEscrowed",
            "type": "uint256"
        }, { "name": "_sharesEscrowed", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, market, amount, price, sender, blockNumber, outcome, moneyEscrowed, sharesEscrowed]);
        return <Bytes32>result.result
    };

    public assertIsNotBetterPrice_ = async (type: UInt8, price: UInt256<TLargeInteger>, betterOrderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x19, 0xe5, 0x4f, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_betterOrderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, betterOrderId]);
        return <boolean>result.result
    };

    public trade_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1f, 0x0b, 0xa6, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public recordFillOrder = async (orderId: Bytes32, sharesFilled: UInt256<TLargeInteger>, tokensFilled: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x2e, 0xd5, 0xca, 0x29]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_sharesFilled", "type": "uint256" }, { "name": "_tokensFilled", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [orderId, sharesFilled, tokensFilled], { transactionName: 'recordFillOrder' })
    };

    public recordFillOrder_ = async (orderId: Bytes32, sharesFilled: UInt256<TLargeInteger>, tokensFilled: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x2e, 0xd5, 0xca, 0x29]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_sharesFilled", "type": "uint256" }, { "name": "_tokensFilled", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId, sharesFilled, tokensFilled]);
        return <boolean>result.result
    };

    public setPrice = async (market: Address, outcome: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x30, 0x11, 0xe1, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }, { "name": "_price", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [market, outcome, price], { transactionName: 'setPrice' })
    };

    public setPrice_ = async (market: Address, outcome: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x30, 0x11, 0xe1, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }, { "name": "_price", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, outcome, price]);
        return <boolean>result.result
    };

    public getPrice_ = async (orderId: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x31, 0xd9, 0x8b, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getTotalEscrowed_ = async (market: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x37, 0xec, 0x11, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_market", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market]);
        return <UInt256<TLargeInteger>>result.result
    };

    public findBoundingOrders = async (type: UInt8, price: UInt256<TLargeInteger>, bestOrderId: Bytes32, worstOrderId: Bytes32, betterOrderId: Bytes32, worseOrderId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3b, 0x01, 0xcf, 0x3c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_bestOrderId",
            "type": "bytes32"
        }, { "name": "_worstOrderId", "type": "bytes32" }, {
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [type, price, bestOrderId, worstOrderId, betterOrderId, worseOrderId], { transactionName: 'findBoundingOrders' })
    };

    public findBoundingOrders_ = async (type: UInt8, price: UInt256<TLargeInteger>, bestOrderId: Bytes32, worstOrderId: Bytes32, betterOrderId: Bytes32, worseOrderId: Bytes32, options?: {}): Promise<{ betterOrderId: Bytes32, worseOrderId: Bytes32 }> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3b, 0x01, 0xcf, 0x3c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_bestOrderId",
            "type": "bytes32"
        }, { "name": "_worstOrderId", "type": "bytes32" }, {
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "betterOrderId",
            "type": "bytes32"
        }, { "name": "worseOrderId", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, bestOrderId, worstOrderId, betterOrderId, worseOrderId]);
        return <{ betterOrderId: Bytes32, worseOrderId: Bytes32 }>result
    };

    public assertIsNotWorsePrice = async (type: UInt8, price: UInt256<TLargeInteger>, worseOrderId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x45, 0xc9, 0x2c, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_worseOrderId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [type, price, worseOrderId], { transactionName: 'assertIsNotWorsePrice' })
    };

    public assertIsNotWorsePrice_ = async (type: UInt8, price: UInt256<TLargeInteger>, worseOrderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x45, 0xc9, 0x2c, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_worseOrderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, worseOrderId]);
        return <boolean>result.result
    };

    public getOrderMoneyEscrowed_ = async (orderId: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4a, 0x1a, 0x34, 0x2b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt256<TLargeInteger>>result.result
    };

    public fillOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5c, 0x1a, 0xd8, 0x44]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public isBetterPrice_ = async (type: UInt8, price: UInt256<TLargeInteger>, orderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5c, 0xf1, 0x7b, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, orderId]);
        return <boolean>result.result
    };

    public getOutcome_ = async (orderId: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5d, 0x1a, 0x3b, 0x82]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt256<TLargeInteger>>result.result
    };

    public createOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x65, 0x12, 0xe6, 0xec]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public cancelOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6a, 0x81, 0x65, 0x48]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public testRemoveOrder = async (orderId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6b, 0x91, 0x4c, 0xe1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [orderId], { transactionName: 'testRemoveOrder' })
    };

    public testRemoveOrder_ = async (orderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6b, 0x91, 0x4c, 0xe1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <boolean>result.result
    };

    public saveOrder = async (type: UInt8, market: Address, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, sender: Address, outcome: UInt256<TLargeInteger>, moneyEscrowed: UInt256<TLargeInteger>, sharesEscrowed: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6b, 0xc2, 0x9e, 0xfa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_price",
            "type": "uint256"
        }, { "name": "_sender", "type": "address" }, {
            "name": "_outcome",
            "type": "uint256"
        }, { "name": "_moneyEscrowed", "type": "uint256" }, {
            "name": "_sharesEscrowed",
            "type": "uint256"
        }, { "name": "_betterOrderId", "type": "bytes32" }, {
            "name": "_worseOrderId",
            "type": "bytes32"
        }, { "name": "_tradeGroupId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [type, market, amount, price, sender, outcome, moneyEscrowed, sharesEscrowed, betterOrderId, worseOrderId, tradeGroupId], { transactionName: 'saveOrder' })
    };

    public saveOrder_ = async (type: UInt8, market: Address, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, sender: Address, outcome: UInt256<TLargeInteger>, moneyEscrowed: UInt256<TLargeInteger>, sharesEscrowed: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6b, 0xc2, 0x9e, 0xfa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_price",
            "type": "uint256"
        }, { "name": "_sender", "type": "address" }, {
            "name": "_outcome",
            "type": "uint256"
        }, { "name": "_moneyEscrowed", "type": "uint256" }, {
            "name": "_sharesEscrowed",
            "type": "uint256"
        }, { "name": "_betterOrderId", "type": "bytes32" }, {
            "name": "_worseOrderId",
            "type": "bytes32"
        }, { "name": "_tradeGroupId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, market, amount, price, sender, outcome, moneyEscrowed, sharesEscrowed, betterOrderId, worseOrderId, tradeGroupId]);
        return <Bytes32>result._orderId
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getBestOrderId_ = async (type: UInt8, market: Address, outcome: UInt256<TLargeInteger>, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7b, 0x6e, 0xaa, 0x65]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, market, outcome]);
        return <Bytes32>result.result
    };

    public getLastOutcomePrice_ = async (market: Address, outcome: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x80, 0x4f, 0xb4, 0x10]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, outcome]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getWorseOrderId_ = async (orderId: Bytes32, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x89, 0x25, 0xf9, 0xe9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <Bytes32>result.result
    };

    public getWorstOrderId_ = async (type: UInt8, market: Address, outcome: UInt256<TLargeInteger>, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8e, 0x12, 0xeb, 0xad]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, market, outcome]);
        return <Bytes32>result.result
    };

    public getBetterOrderId_ = async (orderId: Bytes32, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x94, 0xd2, 0x6c, 0xb5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <Bytes32>result.result
    };

    public testSaveOrder = async (type: UInt8, market: Address, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, sender: Address, outcome: UInt256<TLargeInteger>, moneyEscrowed: UInt256<TLargeInteger>, sharesEscrowed: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa2, 0x38, 0x5d, 0xeb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_price",
            "type": "uint256"
        }, { "name": "_sender", "type": "address" }, {
            "name": "_outcome",
            "type": "uint256"
        }, { "name": "_moneyEscrowed", "type": "uint256" }, {
            "name": "_sharesEscrowed",
            "type": "uint256"
        }, { "name": "_betterOrderId", "type": "bytes32" }, {
            "name": "_worseOrderId",
            "type": "bytes32"
        }, { "name": "_tradeGroupId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [type, market, amount, price, sender, outcome, moneyEscrowed, sharesEscrowed, betterOrderId, worseOrderId, tradeGroupId], { transactionName: 'testSaveOrder' })
    };

    public testSaveOrder_ = async (type: UInt8, market: Address, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, sender: Address, outcome: UInt256<TLargeInteger>, moneyEscrowed: UInt256<TLargeInteger>, sharesEscrowed: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa2, 0x38, 0x5d, 0xeb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_price",
            "type": "uint256"
        }, { "name": "_sender", "type": "address" }, {
            "name": "_outcome",
            "type": "uint256"
        }, { "name": "_moneyEscrowed", "type": "uint256" }, {
            "name": "_sharesEscrowed",
            "type": "uint256"
        }, { "name": "_betterOrderId", "type": "bytes32" }, {
            "name": "_worseOrderId",
            "type": "bytes32"
        }, { "name": "_tradeGroupId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, market, amount, price, sender, outcome, moneyEscrowed, sharesEscrowed, betterOrderId, worseOrderId, tradeGroupId]);
        return <Bytes32>result._orderId
    };

    public getMarket_ = async (orderId: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc3, 0xc9, 0x5c, 0x7b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <Address>result.result
    };

    public initialize = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public getOrderType_ = async (orderId: Bytes32, options?: {}): Promise<UInt8> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xcf, 0x35, 0x73, 0x64]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint8" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt8>result.result
    };

    public isWorsePrice_ = async (type: UInt8, price: UInt256<TLargeInteger>, orderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0xb3, 0xd9, 0xfe]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, orderId]);
        return <boolean>result.result
    };

    public getOrderCreator_ = async (orderId: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe7, 0xd8, 0x0c, 0x70]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <Address>result.result
    };

    public getOrderSharesEscrowed_ = async (orderId: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xeb, 0xea, 0xd0, 0x5f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public ascendOrderList_ = async (type: UInt8, price: UInt256<TLargeInteger>, lowestOrderId: Bytes32, options?: {}): Promise<{ _betterOrderId: Bytes32, _worseOrderId: Bytes32 }> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf8, 0x26, 0x6a, 0x7a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_lowestOrderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, lowestOrderId]);
        return <{ _betterOrderId: Bytes32, _worseOrderId: Bytes32 }>result
    };

    public removeOrder = async (orderId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfd, 0xe9, 0x96, 0x68]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [orderId], { transactionName: 'removeOrder' })
    };

    public removeOrder_ = async (orderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfd, 0xe9, 0x96, 0x68]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <boolean>result.result
	}
}


export class Time<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public getTimestamp_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x8e, 0xc3, 0x56]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
	}
}


export class TimeControlled<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public getTimestamp_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x8e, 0xc3, 0x56]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public setTimestamp = async (timestamp: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa0, 0xa2, 0xb5, 0x73]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_timestamp", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [timestamp], { transactionName: 'setTimestamp' })
    };

    public setTimestamp_ = async (timestamp: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa0, 0xa2, 0xb5, 0x73]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_timestamp", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [timestamp]);
        return <boolean>result.result
    };

    public incrementTimestamp = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb6, 0x10, 0xc7, 0x5e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amount], { transactionName: 'incrementTimestamp' })
    };

    public incrementTimestamp_ = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb6, 0x10, 0xc7, 0x5e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amount]);
        return <boolean>result.result
    };

    public initialize = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
	}
}


export class AuctionFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createAuction = async (augur: Address, universe: Address, reputationToken: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf0, 0xd1, 0x86, 0x9b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_reputationToken", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, universe, reputationToken], { transactionName: 'createAuction' })
    };

    public createAuction_ = async (augur: Address, universe: Address, reputationToken: Address, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf0, 0xd1, 0x86, 0x9b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_reputationToken", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, universe, reputationToken]);
        return <Address>result.result
	}
}


export class AuctionTokenFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createAuctionToken = async (augur: Address, auction: Address, redemptionToken: Address, auctionIndex: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x74, 0x29, 0xc3, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_auction", "type": "address" }, {
            "name": "_redemptionToken",
            "type": "address"
        }, { "name": "_auctionIndex", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, auction, redemptionToken, auctionIndex], { transactionName: 'createAuctionToken' })
    };

    public createAuctionToken_ = async (augur: Address, auction: Address, redemptionToken: Address, auctionIndex: UInt256<TLargeInteger>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x74, 0x29, 0xc3, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_auction", "type": "address" }, {
            "name": "_redemptionToken",
            "type": "address"
        }, { "name": "_auctionIndex", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, auction, redemptionToken, auctionIndex]);
        return <Address>result.result
	}
}


export class DisputeCrowdsourcerFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createDisputeCrowdsourcer = async (augur: Address, market: Address, size: UInt256<TLargeInteger>, payoutDistributionHash: Bytes32, payoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc9, 0x0f, 0xeb, 0xfe]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_size",
            "type": "uint256"
        }, { "name": "_payoutDistributionHash", "type": "bytes32" }, {
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, market, size, payoutDistributionHash, payoutNumerators], { transactionName: 'createDisputeCrowdsourcer' })
    };

    public createDisputeCrowdsourcer_ = async (augur: Address, market: Address, size: UInt256<TLargeInteger>, payoutDistributionHash: Bytes32, payoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc9, 0x0f, 0xeb, 0xfe]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_size",
            "type": "uint256"
        }, { "name": "_payoutDistributionHash", "type": "bytes32" }, {
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, market, size, payoutDistributionHash, payoutNumerators]);
        return <Address>result.result
	}
}


export class DisputeWindowFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createDisputeWindow = async (augur: Address, universe: Address, disputeWindowId: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x01, 0xfb, 0x34, 0xbe]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_disputeWindowId", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, universe, disputeWindowId], { transactionName: 'createDisputeWindow' })
    };

    public createDisputeWindow_ = async (augur: Address, universe: Address, disputeWindowId: UInt256<TLargeInteger>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x01, 0xfb, 0x34, 0xbe]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_disputeWindowId", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, universe, disputeWindowId]);
        return <Address>result.result
	}
}


export class InitialReporterFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createInitialReporter = async (augur: Address, market: Address, designatedReporter: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb3, 0x09, 0x49, 0xd9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_designatedReporter", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, market, designatedReporter], { transactionName: 'createInitialReporter' })
    };

    public createInitialReporter_ = async (augur: Address, market: Address, designatedReporter: Address, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb3, 0x09, 0x49, 0xd9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_designatedReporter", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, market, designatedReporter]);
        return <Address>result.result
	}
}


export class MapFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createMap = async (augur: Address, owner: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb7, 0x82, 0xf6, 0x13]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_owner", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, owner], { transactionName: 'createMap' })
    };

    public createMap_ = async (augur: Address, owner: Address, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb7, 0x82, 0xf6, 0x13]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_owner", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, owner]);
        return <Address>result.result
	}
}


export class MarketFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createMarket = async (augur: Address, universe: Address, endTime: UInt256<TLargeInteger>, feePerEthInWei: UInt256<TLargeInteger>, designatedReporterAddress: Address, sender: Address, numOutcomes: UInt256<TLargeInteger>, numTicks: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x07, 0xad, 0x2c, 0x09]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, {
            "name": "_endTime",
            "type": "uint256"
        }, { "name": "_feePerEthInWei", "type": "uint256" }, {
            "name": "_designatedReporterAddress",
            "type": "address"
        }, { "name": "_sender", "type": "address" }, {
            "name": "_numOutcomes",
            "type": "uint256"
        }, { "name": "_numTicks", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, universe, endTime, feePerEthInWei, designatedReporterAddress, sender, numOutcomes, numTicks], { transactionName: 'createMarket' })
    };

    public createMarket_ = async (augur: Address, universe: Address, endTime: UInt256<TLargeInteger>, feePerEthInWei: UInt256<TLargeInteger>, designatedReporterAddress: Address, sender: Address, numOutcomes: UInt256<TLargeInteger>, numTicks: UInt256<TLargeInteger>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x07, 0xad, 0x2c, 0x09]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, {
            "name": "_endTime",
            "type": "uint256"
        }, { "name": "_feePerEthInWei", "type": "uint256" }, {
            "name": "_designatedReporterAddress",
            "type": "address"
        }, { "name": "_sender", "type": "address" }, {
            "name": "_numOutcomes",
            "type": "uint256"
        }, { "name": "_numTicks", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_market", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, universe, endTime, feePerEthInWei, designatedReporterAddress, sender, numOutcomes, numTicks]);
        return <Address>result._market
	}
}


export class ReputationTokenFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createReputationToken = async (augur: Address, universe: Address, parentUniverse: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa1, 0x32, 0xb4, 0x8f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_parentUniverse", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, universe, parentUniverse], { transactionName: 'createReputationToken' })
    };

    public createReputationToken_ = async (augur: Address, universe: Address, parentUniverse: Address, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa1, 0x32, 0xb4, 0x8f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_parentUniverse", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, universe, parentUniverse]);
        return <Address>result.result
	}
}


export class ShareTokenFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createShareToken = async (augur: Address, market: Address, outcome: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5f, 0x97, 0x70, 0x9a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, market, outcome], { transactionName: 'createShareToken' })
    };

    public createShareToken_ = async (augur: Address, market: Address, outcome: UInt256<TLargeInteger>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5f, 0x97, 0x70, 0x9a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, market, outcome]);
        return <Address>result.result
	}
}


export class TestNetReputationTokenFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createReputationToken = async (augur: Address, universe: Address, parentUniverse: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa1, 0x32, 0xb4, 0x8f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_parentUniverse", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, universe, parentUniverse], { transactionName: 'createReputationToken' })
    };

    public createReputationToken_ = async (augur: Address, universe: Address, parentUniverse: Address, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa1, 0x32, 0xb4, 0x8f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_parentUniverse", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, universe, parentUniverse]);
        return <Address>result.result
	}
}


export class UniverseFactory<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createUniverse = async (augur: Address, parentUniverse: Address, parentPayoutDistributionHash: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x48, 0x37, 0x43, 0x5f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_parentUniverse", "type": "address" }, {
            "name": "_parentPayoutDistributionHash",
            "type": "bytes32"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, parentUniverse, parentPayoutDistributionHash], { transactionName: 'createUniverse' })
    };

    public createUniverse_ = async (augur: Address, parentUniverse: Address, parentPayoutDistributionHash: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x48, 0x37, 0x43, 0x5f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_parentUniverse", "type": "address" }, {
            "name": "_parentPayoutDistributionHash",
            "type": "bytes32"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, parentUniverse, parentPayoutDistributionHash]);
        return <Address>result.result
	}
}


export class DelegationTarget<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public controllerLookupName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbe, 0xf7, 0x2f, 0xa2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
	}
}


export class Map<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public contains_ = async (key: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1d, 0x1a, 0x69, 0x6d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_key", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [key]);
        return <boolean>result.result
    };

    public add = async (key: Bytes32, value: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x61, 0x64, 0x1b, 0xdc]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_key",
            "type": "bytes32"
        }, { "name": "_value", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [key, value], { transactionName: 'add' })
    };

    public add_ = async (key: Bytes32, value: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x61, 0x64, 0x1b, 0xdc]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_key",
            "type": "bytes32"
        }, { "name": "_value", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [key, value]);
        return <boolean>result.result
    };

    public getAsAddress_ = async (key: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x79, 0xf5, 0x7e, 0x68]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_key", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [key]);
        return <Address>result.result
    };

    public getValueOrZero_ = async (key: Bytes32, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x81, 0x96, 0xb8, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_key", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [key]);
        return <Bytes32>result.result
    };

    public getOwner_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x89, 0x3d, 0x20, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public get_ = async (key: Bytes32, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8e, 0xaa, 0x6a, 0xc0]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_key", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [key]);
        return <Bytes32>result.result
    };

    public remove = async (key: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xbc, 0x26, 0x73]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_key", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [key], { transactionName: 'remove' })
    };

    public remove_ = async (key: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xbc, 0x26, 0x73]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_key", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [key]);
        return <boolean>result.result
    };

    public getCount_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa8, 0x7d, 0x94, 0x2c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public initialize = async (owner: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_owner", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [owner], { transactionName: 'initialize' })
    };

    public initialize_ = async (owner: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_owner", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owner]);
        return <boolean>result.result
    };

    public getAsAddressOrZero_ = async (key: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd8, 0xe5, 0xe6, 0x4e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_key", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [key]);
        return <Address>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public transferOwnership = async (newOwner: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0xfd, 0xe3, 0x8b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newOwner", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [newOwner], { transactionName: 'transferOwnership' })
    };

    public transferOwnership_ = async (newOwner: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0xfd, 0xe3, 0x8b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newOwner", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [newOwner]);
        return <boolean>result.result
	}
}


export class Auction<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public getAuctionIndexForCurrentTime_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x04, 0x2d, 0xfb, 0x4e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getCurrentAttoEthBalance = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x05, 0x72, 0xb0, 0x9c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getCurrentAttoEthBalance' })
    };

    public getCurrentAttoEthBalance_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x05, 0x72, 0xb0, 0x9c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public lastRepPrice_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0x94, 0x2f, 0x0a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getCurrentAttoRepBalance = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0c, 0xf6, 0x90, 0xec]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getCurrentAttoRepBalance' })
    };

    public getCurrentAttoRepBalance_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0c, 0xf6, 0x90, 0xec]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getRepPriceInAttoEth_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0f, 0x8f, 0xd3, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public initializationTime_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x21, 0x88, 0x25, 0xbf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public isActive_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x22, 0xf3, 0xe2, 0xd4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public tradeRepForEth = async (attoEthAmount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x29, 0xcf, 0x0c, 0x1c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_attoEthAmount",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [attoEthAmount], { transactionName: 'tradeRepForEth' })
    };

    public tradeRepForEth_ = async (attoEthAmount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x29, 0xcf, 0x0c, 0x1c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_attoEthAmount",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [attoEthAmount]);
        return <boolean>result.result
    };

    public initializeNewAuction = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x30, 0x88, 0x30, 0xe1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'initializeNewAuction' })
    };

    public initializeNewAuction_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x30, 0x88, 0x30, 0xe1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public bootstrapped_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x35, 0x14, 0x2c, 0x8c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getRepSalePriceInAttoEth = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x44, 0xa2, 0x0c, 0xe5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getRepSalePriceInAttoEth' })
    };

    public getRepSalePriceInAttoEth_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x44, 0xa2, 0x0c, 0xe5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public currentRoundType_ = async (options?: {}): Promise<UInt8> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x46, 0xae, 0x6b, 0xc3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint8" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt8>result.result
    };

    public initialRepSalePrice_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x47, 0xdc, 0x89, 0xc8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public auctionTokenFactory_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x56, 0x94, 0x08, 0x55]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public currentAuctionIndex_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x58, 0x88, 0x2e, 0x7f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public tradeEthForRep = async (attoRepAmount: UInt256<TLargeInteger>, options?: { attachedEth?: UInt256<TLargeInteger> }): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5f, 0x25, 0x55, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_attoRepAmount",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [attoRepAmount], { transactionName: 'tradeEthForRep' }, options.attachedEth)
    };

    public tradeEthForRep_ = async (attoRepAmount: UInt256<TLargeInteger>, options?: { attachedEth?: UInt256<TLargeInteger> }): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5f, 0x25, 0x55, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_attoRepAmount",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [attoRepAmount], options.attachedEth);
        return <boolean>result.result
    };

    public feeBalance_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x60, 0xb7, 0x1d, 0x4e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public initialEthSalePrice_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x70, 0xf5, 0x03, 0xa4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public initialRepPriceInAttoEth_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x74, 0xfa, 0x62, 0x81]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getAuctionEndTime_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x78, 0x7c, 0x0a, 0x6c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getUniverse_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x87, 0x0c, 0x42, 0x6d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public repAuctionToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8c, 0xf9, 0x42, 0xb6]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getEthSalePriceInAttoRep = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8e, 0xb6, 0xde, 0x1b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getEthSalePriceInAttoRep' })
    };

    public getEthSalePriceInAttoRep_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8e, 0xb6, 0xde, 0x1b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public bootstrapMode_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x63, 0xdd, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public cash_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x96, 0x1b, 0xe3, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public initialAttoEthBalance_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9b, 0x33, 0x82, 0xb0]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public initialAttoRepBalance_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa4, 0x19, 0x62, 0x6d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getDerivedRepPriceInAttoEth_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa5, 0x96, 0x84, 0x12]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getAuctionStartTime_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb0, 0x43, 0x10, 0x00]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public repPrice_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb0, 0x4a, 0xc0, 0x3a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getReputationToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x09, 0x07, 0xf2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public initialize = async (augur: Address, universe: Address, reputationToken: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc0, 0xc5, 0x3b, 0x8b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_reputationToken", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, universe, reputationToken], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, universe: Address, reputationToken: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc0, 0xc5, 0x3b, 0x8b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_reputationToken", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, universe, reputationToken]);
        return <boolean>result.result
    };

    public getRoundType_ = async (options?: {}): Promise<UInt8> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc1, 0xe5, 0xda, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint8" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt8>result.result
    };

    public recordFees = async (feeAmount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd6, 0x8c, 0xee, 0xd8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_feeAmount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [feeAmount], { transactionName: 'recordFees' })
    };

    public recordFees_ = async (feeAmount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd6, 0x8c, 0xee, 0xd8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_feeAmount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [feeAmount]);
        return <boolean>result.result
    };

    public ethAuctionToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdf, 0x26, 0x8b, 0xfa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
	}
}


export class AuctionToken<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public supply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x04, 0x7f, 0xc9, 0xaa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public defaultOperators_ = async (options?: {}): Promise<Array<Address>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xe4, 0x85, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address[]" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Array<Address>>result.result
    };

    public name_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xfd, 0xde, 0x03]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public mintForPurchaser = async (purchaser: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x08, 0xb1, 0x2e, 0x19]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_purchaser",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [purchaser, amount], { transactionName: 'mintForPurchaser' })
    };

    public mintForPurchaser_ = async (purchaser: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x08, 0xb1, 0x2e, 0x19]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_purchaser",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [purchaser, amount]);
        return <boolean>result.result
    };

    public approve = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, amount], { transactionName: 'approve' })
    };

    public approve_ = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, amount]);
        return <boolean>result.result
    };

    public totalSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x16, 0x0d, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public redemptionToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1d, 0xc9, 0x56, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public transferFrom = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount], { transactionName: 'transferFrom' })
    };

    public transferFrom_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount]);
        return <boolean>result.result
    };

    public decimals_ = async (options?: {}): Promise<UInt8> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x31, 0x3c, 0xe5, 0x67]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint8" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt8>result.result
    };

    public initialize = async (augur: Address, auction: Address, redemptionToken: Address, auctionIndex: UInt256<TLargeInteger>, erc820RegistryAddress: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x53, 0x0b, 0x97, 0xa4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_auction", "type": "address" }, {
            "name": "_redemptionToken",
            "type": "address"
        }, { "name": "_auctionIndex", "type": "uint256" }, { "name": "_erc820RegistryAddress", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, auction, redemptionToken, auctionIndex, erc820RegistryAddress], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, auction: Address, redemptionToken: Address, auctionIndex: UInt256<TLargeInteger>, erc820RegistryAddress: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x53, 0x0b, 0x97, 0xa4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_auction", "type": "address" }, {
            "name": "_redemptionToken",
            "type": "address"
        }, { "name": "_auctionIndex", "type": "uint256" }, { "name": "_erc820RegistryAddress", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, auction, redemptionToken, auctionIndex, erc820RegistryAddress]);
        return <boolean>result.result
    };

    public universe_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x55, 0x4c, 0x1b, 0x1f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public granularity_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x55, 0x6f, 0x0d, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public retrieveFunds = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x61, 0xb2, 0x0d, 0x8c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'retrieveFunds' })
    };

    public retrieveFunds_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x61, 0xb2, 0x0d, 0x8c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public ETERNAL_APPROVAL_VALUE_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x63, 0x4e, 0xaf, 0xf1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public decreaseApproval = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, subtractedValue], { transactionName: 'decreaseApproval' })
    };

    public decreaseApproval_ = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, subtractedValue]);
        return <boolean>result.result
    };

    public balanceOf_ = async (tokenHolder: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x70, 0xa0, 0x82, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [tokenHolder]);
        return <UInt256<TLargeInteger>>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public auctionIndex_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0xac, 0xf0, 0x3c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public auction_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7d, 0x9f, 0x6d, 0xb5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public sendNoHooks = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'sendNoHooks' })
    };

    public sendNoHooks_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public authorizeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'authorizeOperator' })
    };

    public authorizeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public symbol_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xd8, 0x9b, 0x41]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public cash_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x96, 0x1b, 0xe3, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public erc820Registry_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x2a, 0x14, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public transfer = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount], { transactionName: 'transfer' })
    };

    public transfer_ = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount]);
        return <boolean>result.result
    };

    public send = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'send' })
    };

    public send_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public redeem = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbe, 0x04, 0x0f, 0xb0]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'redeem' })
    };

    public redeem_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbe, 0x04, 0x0f, 0xb0]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public maxSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd5, 0xab, 0xeb, 0x01]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public increaseApproval = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, addedValue], { transactionName: 'increaseApproval' })
    };

    public increaseApproval_ = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, addedValue]);
        return <boolean>result.result
    };

    public isOperatorFor_ = async (operator: Address, tokenHolder: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0x5b, 0x63, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_operator",
            "type": "address"
        }, { "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator, tokenHolder]);
        return <boolean>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public operatorSend = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount, data, operatorData], { transactionName: 'operatorSend' })
    };

    public operatorSend_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount, data, operatorData]);
        return <boolean>result.result
    };

    public allowance_ = async (owner: Address, spender: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdd, 0x62, 0xed, 0x3e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_spender", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owner, spender]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public revokeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'revokeOperator' })
    };

    public revokeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
	}
}


export class DisputeCrowdsourcer<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public supply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x04, 0x7f, 0xc9, 0xaa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public defaultOperators_ = async (options?: {}): Promise<Array<Address>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xe4, 0x85, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address[]" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Array<Address>>result.result
    };

    public approve = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, amount], { transactionName: 'approve' })
    };

    public approve_ = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, amount]);
        return <boolean>result.result
    };

    public totalSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x16, 0x0d, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public forkAndRedeem = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1d, 0x7b, 0x6d, 0x58]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'forkAndRedeem' })
    };

    public forkAndRedeem_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1d, 0x7b, 0x6d, 0x58]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public liquidateLosing = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x22, 0xb1, 0x52, 0xa3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'liquidateLosing' })
    };

    public liquidateLosing_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x22, 0xb1, 0x52, 0xa3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public transferFrom = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount], { transactionName: 'transferFrom' })
    };

    public transferFrom_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount]);
        return <boolean>result.result
    };

    public decimals_ = async (options?: {}): Promise<UInt8> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x31, 0x3c, 0xe5, 0x67]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint8" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt8>result.result
    };

    public granularity_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x55, 0x6f, 0x0d, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public initialize = async (augur: Address, market: Address, size: UInt256<TLargeInteger>, payoutDistributionHash: Bytes32, payoutNumerators: Array<UInt256<TLargeInteger>>, erc820RegistryAddress: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x60, 0x7e, 0x91, 0xc8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_size",
            "type": "uint256"
        }, { "name": "_payoutDistributionHash", "type": "bytes32" }, {
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_erc820RegistryAddress", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, market, size, payoutDistributionHash, payoutNumerators, erc820RegistryAddress], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, market: Address, size: UInt256<TLargeInteger>, payoutDistributionHash: Bytes32, payoutNumerators: Array<UInt256<TLargeInteger>>, erc820RegistryAddress: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x60, 0x7e, 0x91, 0xc8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_size",
            "type": "uint256"
        }, { "name": "_payoutDistributionHash", "type": "bytes32" }, {
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_erc820RegistryAddress", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, market, size, payoutDistributionHash, payoutNumerators, erc820RegistryAddress]);
        return <boolean>result.result
    };

    public ETERNAL_APPROVAL_VALUE_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x63, 0x4e, 0xaf, 0xf1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public isDisavowed_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x64, 0x02, 0x08, 0x42]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public decreaseApproval = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, subtractedValue], { transactionName: 'decreaseApproval' })
    };

    public decreaseApproval_ = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, subtractedValue]);
        return <boolean>result.result
    };

    public balanceOf_ = async (tokenHolder: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x70, 0xa0, 0x82, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [tokenHolder]);
        return <UInt256<TLargeInteger>>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public sendNoHooks = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'sendNoHooks' })
    };

    public sendNoHooks_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public contribute = async (participant: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x84, 0x18, 0xcd, 0x99]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_participant",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [participant, amount], { transactionName: 'contribute' })
    };

    public contribute_ = async (participant: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x84, 0x18, 0xcd, 0x99]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_participant",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [participant, amount]);
        return <UInt256<TLargeInteger>>result.result
    };

    public authorizeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'authorizeOperator' })
    };

    public authorizeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public redeem = async (redeemer: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xa2, 0x25, 0x1f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_redeemer", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [redeemer], { transactionName: 'redeem' })
    };

    public redeem_ = async (redeemer: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xa2, 0x25, 0x1f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_redeemer", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [redeemer]);
        return <boolean>result.result
    };

    public erc820Registry_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x2a, 0x14, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public transfer = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount], { transactionName: 'transfer' })
    };

    public transfer_ = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount]);
        return <boolean>result.result
    };

    public send = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'send' })
    };

    public send_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public getReputationToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x09, 0x07, 0xf2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public increaseApproval = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, addedValue], { transactionName: 'increaseApproval' })
    };

    public increaseApproval_ = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, addedValue]);
        return <boolean>result.result
    };

    public isOperatorFor_ = async (operator: Address, tokenHolder: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0x5b, 0x63, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_operator",
            "type": "address"
        }, { "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator, tokenHolder]);
        return <boolean>result.result
    };

    public getPayoutNumerator_ = async (outcome: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xda, 0x83, 0x4a, 0xc4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [outcome]);
        return <UInt256<TLargeInteger>>result.result
    };

    public operatorSend = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount, data, operatorData], { transactionName: 'operatorSend' })
    };

    public operatorSend_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount, data, operatorData]);
        return <boolean>result.result
    };

    public allowance_ = async (owner: Address, spender: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdd, 0x62, 0xed, 0x3e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_spender", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owner, spender]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getPayoutDistributionHash_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdd, 0x62, 0xf6, 0xf3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public getSize_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xde, 0x8f, 0xa4, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getMarket_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf1, 0xbe, 0x16, 0x79]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public revokeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'revokeOperator' })
    };

    public revokeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public getStake_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfc, 0x0e, 0x3d, 0x90]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
	}
}


export class DisputeWindow<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public initialize = async (augur: Address, universe: Address, disputeWindowId: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x17, 0x94, 0xbb, 0x3c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_disputeWindowId", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, universe, disputeWindowId], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, universe: Address, disputeWindowId: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x17, 0x94, 0xbb, 0x3c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, { "name": "_disputeWindowId", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, universe, disputeWindowId]);
        return <boolean>result.result
    };

    public isActive_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x22, 0xf3, 0xe2, 0xd4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getNumMarkets_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x29, 0x5c, 0x39, 0xa5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getEndTime_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x43, 0x9f, 0x5a, 0xc2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getUniverse_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x87, 0x0c, 0x42, 0x6d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public onMarketFinalized = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8d, 0xc6, 0xe2, 0xf1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'onMarketFinalized' })
    };

    public onMarketFinalized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8d, 0xc6, 0xe2, 0xf1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getNumIncorrectDesignatedReportMarkets_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa5, 0x2c, 0x05, 0x12]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public isOver_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb4, 0xbd, 0x9e, 0x27]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getReputationToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x09, 0x07, 0xf2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getStartTime_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc8, 0x28, 0x37, 0x1e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getNumInvalidMarkets_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xcf, 0x3d, 0x38, 0x49]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getNumDesignatedReportNoShows_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xda, 0x0b, 0x0c, 0x36]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
	}
}


export class InitialReporter<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public forkAndRedeem = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1d, 0x7b, 0x6d, 0x58]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'forkAndRedeem' })
    };

    public forkAndRedeem_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1d, 0x7b, 0x6d, 0x58]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public liquidateLosing = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x22, 0xb1, 0x52, 0xa3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'liquidateLosing' })
    };

    public liquidateLosing_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x22, 0xb1, 0x52, 0xa3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public designatedReporterShowed_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3b, 0xf8, 0xf3, 0x4a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getDesignatedReporter_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0x6e, 0x24, 0x92]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public isDisavowed_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x64, 0x02, 0x08, 0x42]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public returnRepFromDisavow = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x87, 0x88, 0x2c, 0xb8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'returnRepFromDisavow' })
    };

    public returnRepFromDisavow_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x87, 0x88, 0x2c, 0xb8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getOwner_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x89, 0x3d, 0x20, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public designatedReporterWasCorrect_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8e, 0xd8, 0x82, 0xc5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getReportTimestamp_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x94, 0xa7, 0x71, 0xd7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public redeem = async (arg0: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xa2, 0x25, 0x1f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [arg0], { transactionName: 'redeem' })
    };

    public redeem_ = async (arg0: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xa2, 0x25, 0x1f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [arg0]);
        return <boolean>result.result
    };

    public getReputationToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x09, 0x07, 0xf2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public initialize = async (augur: Address, market: Address, designatedReporter: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc0, 0xc5, 0x3b, 0x8b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_designatedReporter", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, market, designatedReporter], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, market: Address, designatedReporter: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc0, 0xc5, 0x3b, 0x8b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_designatedReporter", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, market, designatedReporter]);
        return <boolean>result.result
    };

    public getPayoutNumerator_ = async (outcome: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xda, 0x83, 0x4a, 0xc4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [outcome]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getPayoutDistributionHash_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdd, 0x62, 0xf6, 0xf3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public getSize_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xde, 0x8f, 0xa4, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public report = async (reporter: Address, payoutDistributionHash: Bytes32, payoutNumerators: Array<UInt256<TLargeInteger>>, initialReportStake: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe2, 0x16, 0x59, 0xa6]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_reporter",
            "type": "address"
        }, { "name": "_payoutDistributionHash", "type": "bytes32" }, {
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_initialReportStake", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [reporter, payoutDistributionHash, payoutNumerators, initialReportStake], { transactionName: 'report' })
    };

    public report_ = async (reporter: Address, payoutDistributionHash: Bytes32, payoutNumerators: Array<UInt256<TLargeInteger>>, initialReportStake: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe2, 0x16, 0x59, 0xa6]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_reporter",
            "type": "address"
        }, { "name": "_payoutDistributionHash", "type": "bytes32" }, {
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_initialReportStake", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [reporter, payoutDistributionHash, payoutNumerators, initialReportStake]);
        return <boolean>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public migrateToNewUniverse = async (designatedReporter: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xef, 0x0c, 0xe3, 0x7a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_designatedReporter",
            "type": "address"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [designatedReporter], { transactionName: 'migrateToNewUniverse' })
    };

    public migrateToNewUniverse_ = async (designatedReporter: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xef, 0x0c, 0xe3, 0x7a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_designatedReporter",
            "type": "address"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [designatedReporter]);
        return <boolean>result.result
    };

    public getMarket_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf1, 0xbe, 0x16, 0x79]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public transferOwnership = async (newOwner: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0xfd, 0xe3, 0x8b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newOwner", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [newOwner], { transactionName: 'transferOwnership' })
    };

    public transferOwnership_ = async (newOwner: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0xfd, 0xe3, 0x8b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newOwner", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [newOwner]);
        return <boolean>result.result
    };

    public getStake_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfc, 0x0e, 0x3d, 0x90]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
	}
}


export class Market<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public isInvalid_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x04, 0xbe, 0x2f, 0x50]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public derivePayoutDistributionHash_ = async (payoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x17, 0x30, 0x29, 0xd7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [payoutNumerators]);
        return <Bytes32>result.result
    };

    public getInitialReporter_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1a, 0x37, 0x39, 0xec]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getMarketCreatorSettlementFeeDivisor_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1c, 0x7f, 0x3a, 0x96]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getDisputeWindow_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1e, 0x19, 0x08, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getNumberOfOutcomes_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x27, 0xce, 0x5b, 0x8c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getParticipantStake_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x2c, 0x15, 0x43, 0x45]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public participants_ = async (arg0: UInt256<TLargeInteger>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x35, 0xc1, 0xd3, 0x49]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [arg0]);
        return <Address>result.result
    };

    public designatedReporterShowed_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3b, 0xf8, 0xf3, 0x4a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getWinningPayoutNumerator_ = async (outcome: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3c, 0x26, 0x48, 0x20]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [outcome]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getDisputePacingOn_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x41, 0x29, 0x79, 0xb5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getEndTime_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x43, 0x9f, 0x5a, 0xc2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public disavowCrowdsourcers = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x44, 0x9d, 0x0f, 0x29]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'disavowCrowdsourcers' })
    };

    public disavowCrowdsourcers_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x44, 0x9d, 0x0f, 0x29]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public finalize = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4b, 0xb2, 0x78, 0xf3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'finalize' })
    };

    public finalize_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4b, 0xb2, 0x78, 0xf3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public isContainerForShareToken_ = async (shadyShareToken: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x50, 0x9a, 0x10, 0x61]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_shadyShareToken",
            "type": "address"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [shadyShareToken]);
        return <boolean>result.result
    };

    public getDesignatedReporter_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0x6e, 0x24, 0x92]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public initialize = async (augur: Address, universe: Address, endTime: UInt256<TLargeInteger>, feePerEthInAttoEth: UInt256<TLargeInteger>, designatedReporterAddress: Address, creator: Address, numOutcomes: UInt256<TLargeInteger>, numTicks: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0x99, 0xcb, 0x72]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, {
            "name": "_endTime",
            "type": "uint256"
        }, { "name": "_feePerEthInAttoEth", "type": "uint256" }, {
            "name": "_designatedReporterAddress",
            "type": "address"
        }, { "name": "_creator", "type": "address" }, {
            "name": "_numOutcomes",
            "type": "uint256"
        }, { "name": "_numTicks", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, universe, endTime, feePerEthInAttoEth, designatedReporterAddress, creator, numOutcomes, numTicks], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, universe: Address, endTime: UInt256<TLargeInteger>, feePerEthInAttoEth: UInt256<TLargeInteger>, designatedReporterAddress: Address, creator: Address, numOutcomes: UInt256<TLargeInteger>, numTicks: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0x99, 0xcb, 0x72]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_universe", "type": "address" }, {
            "name": "_endTime",
            "type": "uint256"
        }, { "name": "_feePerEthInAttoEth", "type": "uint256" }, {
            "name": "_designatedReporterAddress",
            "type": "address"
        }, { "name": "_creator", "type": "address" }, {
            "name": "_numOutcomes",
            "type": "uint256"
        }, { "name": "_numTicks", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_success", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, universe, endTime, feePerEthInAttoEth, designatedReporterAddress, creator, numOutcomes, numTicks]);
        return <boolean>result._success
    };

    public getShareToken_ = async (outcome: UInt256<TLargeInteger>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x65, 0x95, 0x7b, 0xf5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [outcome]);
        return <Address>result.result
    };

    public getStakeInOutcome_ = async (payoutDistributionHash: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0xd1, 0x2f, 0xad]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutDistributionHash",
            "type": "bytes32"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [payoutDistributionHash]);
        return <UInt256<TLargeInteger>>result.result
    };

    public crowdsourcers_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0xe2, 0x0b, 0x51]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getWinningReportingParticipant_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6e, 0x10, 0x66, 0x28]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public recordMarketCreatorFees = async (marketCreatorFees: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x80, 0x8e, 0x40, 0x5e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_marketCreatorFees",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [marketCreatorFees], { transactionName: 'recordMarketCreatorFees' })
    };

    public recordMarketCreatorFees_ = async (marketCreatorFees: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x80, 0x8e, 0x40, 0x5e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_marketCreatorFees",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [marketCreatorFees]);
        return <boolean>result.result
    };

    public getWinningPayoutDistributionHash_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x10, 0x0b, 0xe6]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public getUniverse_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x87, 0x0c, 0x42, 0x6d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getOwner_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x89, 0x3d, 0x20, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public isFinalized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8d, 0x4e, 0x40, 0x83]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public approveSpenders = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8d, 0x7e, 0x8a, 0x57]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'approveSpenders' })
    };

    public approveSpenders_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8d, 0x7e, 0x8a, 0x57]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public designatedReporterWasCorrect_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8e, 0xd8, 0x82, 0xc5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getValidityBondAttoEth_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x97, 0x97, 0x72, 0xe3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getDesignatedReportingEndTime_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x94, 0x1f, 0x69]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public assertBalances_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa0, 0x69, 0x5f, 0x24]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getFinalizationTime_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa0, 0xe1, 0x6f, 0xed]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public marketCreatorFeesAttoEth_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb7, 0x68, 0x7c, 0x45]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getReputationToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x09, 0x07, 0xf2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getNumTicks_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xba, 0xd8, 0x4c, 0x9e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getReportingParticipant_ = async (index: UInt256<TLargeInteger>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbb, 0xd3, 0x7e, 0xf3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_index", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [index]);
        return <Address>result.result
    };

    public getCrowdsourcer_ = async (payoutDistributionHash: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc3, 0x5c, 0x08, 0xbd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutDistributionHash",
            "type": "bytes32"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [payoutDistributionHash]);
        return <Address>result.result
    };

    public finalizeFork = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc3, 0xfc, 0x47, 0x87]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'finalizeFork' })
    };

    public finalizeFork_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc3, 0xfc, 0x47, 0x87]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getInitialReporterAddress_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc7, 0x60, 0x0c, 0xde]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getForkingMarket_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xcb, 0x1d, 0x84, 0x18]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public getDenominationToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdf, 0x2a, 0x29, 0xda]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public migrateThroughOneFork = async (payoutNumerators: Array<UInt256<TLargeInteger>>, description: string, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdf, 0x70, 0x3a, 0x95]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_description", "type": "string" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [payoutNumerators, description], { transactionName: 'migrateThroughOneFork' })
    };

    public migrateThroughOneFork_ = async (payoutNumerators: Array<UInt256<TLargeInteger>>, description: string, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdf, 0x70, 0x3a, 0x95]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_description", "type": "string" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [payoutNumerators, description]);
        return <boolean>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public transferOwnership = async (newOwner: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0xfd, 0xe3, 0x8b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newOwner", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [newOwner], { transactionName: 'transferOwnership' })
    };

    public transferOwnership_ = async (newOwner: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0xfd, 0xe3, 0x8b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newOwner", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [newOwner]);
        return <boolean>result.result
    };

    public isContainerForReportingParticipant_ = async (shadyReportingParticipant: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf7, 0x65, 0x14, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_shadyReportingParticipant",
            "type": "address"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [shadyReportingParticipant]);
        return <boolean>result.result
    };

    public contribute = async (payoutNumerators: Array<UInt256<TLargeInteger>>, amount: UInt256<TLargeInteger>, description: string, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf8, 0x9d, 0x50, 0x66]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_description", "type": "string" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [payoutNumerators, amount, description], { transactionName: 'contribute' })
    };

    public contribute_ = async (payoutNumerators: Array<UInt256<TLargeInteger>>, amount: UInt256<TLargeInteger>, description: string, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf8, 0x9d, 0x50, 0x66]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_description", "type": "string" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [payoutNumerators, amount, description]);
        return <boolean>result.result
    };

    public deriveMarketCreatorFeeAmount_ = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf8, 0xc5, 0x21, 0x25]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amount]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getNumParticipants_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfd, 0x47, 0x8c, 0xa9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public doInitialReport = async (payoutNumerators: Array<UInt256<TLargeInteger>>, description: string, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xff, 0x41, 0x9d, 0xcf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_description", "type": "string" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [payoutNumerators, description], { transactionName: 'doInitialReport' })
    };

    public doInitialReport_ = async (payoutNumerators: Array<UInt256<TLargeInteger>>, description: string, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xff, 0x41, 0x9d, 0xcf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_description", "type": "string" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [payoutNumerators, description]);
        return <boolean>result.result
	}
}


export class ReputationToken<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public supply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x04, 0x7f, 0xc9, 0xaa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public defaultOperators_ = async (options?: {}): Promise<Array<Address>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xe4, 0x85, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address[]" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Array<Address>>result.result
    };

    public name_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xfd, 0xde, 0x03]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public approve = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, amount], { transactionName: 'approve' })
    };

    public approve_ = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, amount]);
        return <boolean>result.result
    };

    public totalSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x16, 0x0d, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getTotalTheoreticalSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0x8d, 0x35, 0x90]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public transferFrom = async (from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, value], { transactionName: 'transferFrom' })
    };

    public transferFrom_ = async (from: Address, to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, value]);
        return <boolean>result.result
    };

    public decimals_ = async (options?: {}): Promise<UInt8> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x31, 0x3c, 0xe5, 0x67]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint8" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt8>result.result
    };

    public granularity_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x55, 0x6f, 0x0d, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public migrateOutByPayout = async (payoutNumerators: Array<UInt256<TLargeInteger>>, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0x66, 0x87, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [payoutNumerators, attotokens], { transactionName: 'migrateOutByPayout' })
    };

    public migrateOutByPayout_ = async (payoutNumerators: Array<UInt256<TLargeInteger>>, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0x66, 0x87, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_payoutNumerators",
            "type": "uint256[]"
        }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [payoutNumerators, attotokens]);
        return <boolean>result.result
    };

    public burnForAuction = async (amountToBurn: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x60, 0x17, 0x41, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToBurn", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amountToBurn], { transactionName: 'burnForAuction' })
    };

    public burnForAuction_ = async (amountToBurn: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x60, 0x17, 0x41, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToBurn", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amountToBurn]);
        return <boolean>result.result
    };

    public ETERNAL_APPROVAL_VALUE_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x63, 0x4e, 0xaf, 0xf1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public decreaseApproval = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, subtractedValue], { transactionName: 'decreaseApproval' })
    };

    public decreaseApproval_ = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, subtractedValue]);
        return <boolean>result.result
    };

    public migrateOut = async (destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6e, 0x7c, 0xe5, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_destination",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [destination, attotokens], { transactionName: 'migrateOut' })
    };

    public migrateOut_ = async (destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6e, 0x7c, 0xe5, 0x91]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_destination",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [destination, attotokens]);
        return <boolean>result.result
    };

    public balanceOf_ = async (tokenHolder: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x70, 0xa0, 0x82, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [tokenHolder]);
        return <UInt256<TLargeInteger>>result.result
    };

    public migrateFromLegacyReputationToken = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x75, 0xd9, 0xaa, 0x1a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'migrateFromLegacyReputationToken' })
    };

    public migrateFromLegacyReputationToken_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x75, 0xd9, 0xaa, 0x1a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getLegacyRepToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x77, 0x46, 0x92, 0x75]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public sendNoHooks = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'sendNoHooks' })
    };

    public sendNoHooks_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public getUniverse_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x87, 0x0c, 0x42, 0x6d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getTotalMigrated_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x91, 0xd7, 0x6b, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public authorizeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'authorizeOperator' })
    };

    public authorizeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public symbol_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xd8, 0x9b, 0x41]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public trustedAuctionTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x97, 0xfa, 0x56, 0xc1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedAuctionTransfer' })
    };

    public trustedAuctionTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x97, 0xfa, 0x56, 0xc1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public erc820Registry_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x2a, 0x14, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public migrateIn = async (reporter: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa0, 0xc1, 0xca, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_reporter",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [reporter, attotokens], { transactionName: 'migrateIn' })
    };

    public migrateIn_ = async (reporter: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa0, 0xc1, 0xca, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_reporter",
            "type": "address"
        }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [reporter, attotokens]);
        return <boolean>result.result
    };

    public transfer = async (to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_value", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, value], { transactionName: 'transfer' })
    };

    public transfer_ = async (to: Address, value: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_value", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, value]);
        return <boolean>result.result
    };

    public burnForMarket = async (amountToBurn: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xae, 0x38, 0x16, 0xee]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToBurn", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amountToBurn], { transactionName: 'burnForMarket' })
    };

    public burnForMarket_ = async (amountToBurn: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xae, 0x38, 0x16, 0xee]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToBurn", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amountToBurn]);
        return <boolean>result.result
    };

    public send = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'send' })
    };

    public send_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public trustedReportingParticipantTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x73, 0xe9, 0xa7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedReportingParticipantTransfer' })
    };

    public trustedReportingParticipantTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x73, 0xe9, 0xa7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public mintForAuction = async (amountToMint: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbb, 0x05, 0xc7, 0x06]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToMint", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amountToMint], { transactionName: 'mintForAuction' })
    };

    public mintForAuction_ = async (amountToMint: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbb, 0x05, 0xc7, 0x06]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amountToMint", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amountToMint]);
        return <boolean>result.result
    };

    public legacyRepToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd5, 0x46, 0x67, 0x77]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public increaseApproval = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, addedValue], { transactionName: 'increaseApproval' })
    };

    public increaseApproval_ = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, addedValue]);
        return <boolean>result.result
    };

    public isOperatorFor_ = async (operator: Address, tokenHolder: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0x5b, 0x63, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_operator",
            "type": "address"
        }, { "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator, tokenHolder]);
        return <boolean>result.result
    };

    public updateTotalTheoreticalSupply = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xda, 0xcf, 0xed, 0xab]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'updateTotalTheoreticalSupply' })
    };

    public updateTotalTheoreticalSupply_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xda, 0xcf, 0xed, 0xab]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public mintForReportingParticipant = async (amountMigrated: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x05, 0x41, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_amountMigrated",
            "type": "uint256"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amountMigrated], { transactionName: 'mintForReportingParticipant' })
    };

    public mintForReportingParticipant_ = async (amountMigrated: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x05, 0x41, 0x34]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_amountMigrated",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amountMigrated]);
        return <boolean>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public operatorSend = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount, data, operatorData], { transactionName: 'operatorSend' })
    };

    public operatorSend_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount, data, operatorData]);
        return <boolean>result.result
    };

    public allowance_ = async (owner: Address, spender: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdd, 0x62, 0xed, 0x3e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_spender", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owner, spender]);
        return <UInt256<TLargeInteger>>result.result
    };

    public trustedMarketTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0x2b, 0x25, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedMarketTransfer' })
    };

    public trustedMarketTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0x2b, 0x25, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public revokeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'revokeOperator' })
    };

    public revokeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public trustedUniverseTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfe, 0x98, 0x18, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedUniverseTransfer' })
    };

    public trustedUniverseTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfe, 0x98, 0x18, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
	}
}


export class Universe<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public createYesNoMarket = async (endTime: UInt256<TLargeInteger>, feePerEthInWei: UInt256<TLargeInteger>, designatedReporterAddress: Address, topic: Bytes32, description: string, extraInfo: string, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x01, 0x6f, 0xb0, 0x98]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_endTime",
            "type": "uint256"
        }, { "name": "_feePerEthInWei", "type": "uint256" }, {
            "name": "_designatedReporterAddress",
            "type": "address"
        }, { "name": "_topic", "type": "bytes32" }, {
            "name": "_description",
            "type": "string"
        }, { "name": "_extraInfo", "type": "string" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [endTime, feePerEthInWei, designatedReporterAddress, topic, description, extraInfo], { transactionName: 'createYesNoMarket' })
    };

    public createYesNoMarket_ = async (endTime: UInt256<TLargeInteger>, feePerEthInWei: UInt256<TLargeInteger>, designatedReporterAddress: Address, topic: Bytes32, description: string, extraInfo: string, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x01, 0x6f, 0xb0, 0x98]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_endTime",
            "type": "uint256"
        }, { "name": "_feePerEthInWei", "type": "uint256" }, {
            "name": "_designatedReporterAddress",
            "type": "address"
        }, { "name": "_topic", "type": "bytes32" }, {
            "name": "_description",
            "type": "string"
        }, { "name": "_extraInfo", "type": "string" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newMarket", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [endTime, feePerEthInWei, designatedReporterAddress, topic, description, extraInfo]);
        return <Address>result._newMarket
    };

    public isContainerForDisputeWindow_ = async (shadyDisputeWindow: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x01, 0xba, 0x1f, 0xa3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_shadyDisputeWindow",
            "type": "address"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [shadyDisputeWindow]);
        return <boolean>result.result
    };

    public getOrCreateNextDisputeWindow = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x03, 0x6b, 0x8e, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getOrCreateNextDisputeWindow' })
    };

    public getOrCreateNextDisputeWindow_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x03, 0x6b, 0x8e, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getDisputeThresholdForDisputePacing_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x04, 0x78, 0x25, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public incrementOpenInterestFromMarket = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0x17, 0x77, 0xed]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amount], { transactionName: 'incrementOpenInterestFromMarket' })
    };

    public incrementOpenInterestFromMarket_ = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0x17, 0x77, 0xed]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amount]);
        return <boolean>result.result
    };

    public marketFactory_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xae, 0x70, 0x95]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public decrementOpenInterestFromMarket = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0d, 0xb3, 0xbe, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amount], { transactionName: 'decrementOpenInterestFromMarket' })
    };

    public decrementOpenInterestFromMarket_ = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0d, 0xb3, 0xbe, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amount]);
        return <boolean>result.result
    };

    public getOrCreateDisputeWindowByTimestamp = async (timestamp: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0e, 0x5a, 0x59, 0xa6]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_timestamp", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [timestamp], { transactionName: 'getOrCreateDisputeWindowByTimestamp' })
    };

    public getOrCreateDisputeWindowByTimestamp_ = async (timestamp: UInt256<TLargeInteger>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0e, 0x5a, 0x59, 0xa6]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_timestamp", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [timestamp]);
        return <Address>result.result
    };

    public getTargetRepMarketCapInAttoEth_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x15, 0x02, 0xa0, 0xb1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getOrCreatePreviousPreviousDisputeWindow = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x22, 0x37, 0x00, 0xd8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getOrCreatePreviousPreviousDisputeWindow' })
    };

    public getOrCreatePreviousPreviousDisputeWindow_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x22, 0x37, 0x00, 0xd8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getNextDisputeWindow_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x32, 0x22, 0xf5, 0xe7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getDisputeRoundDurationInSeconds_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x33, 0x11, 0x72, 0xf3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public createChildUniverse = async (parentPayoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3a, 0x53, 0x71, 0x76]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_parentPayoutNumerators",
            "type": "uint256[]"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [parentPayoutNumerators], { transactionName: 'createChildUniverse' })
    };

    public createChildUniverse_ = async (parentPayoutNumerators: Array<UInt256<TLargeInteger>>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3a, 0x53, 0x71, 0x76]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_parentPayoutNumerators",
            "type": "uint256[]"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [parentPayoutNumerators]);
        return <Address>result.result
    };

    public fork = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x45, 0x91, 0xc0, 0x60]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'fork' })
    };

    public fork_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x45, 0x91, 0xc0, 0x60]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getOrCreatePreviousDisputeWindow = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4d, 0x4a, 0x77, 0x4e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getOrCreatePreviousDisputeWindow' })
    };

    public getOrCreatePreviousDisputeWindow_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4d, 0x4a, 0x77, 0x4e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public isContainerForShareToken_ = async (shadyShareToken: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x50, 0x9a, 0x10, 0x61]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_shadyShareToken",
            "type": "address"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [shadyShareToken]);
        return <boolean>result.result
    };

    public getPreviousDisputeWindow_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x59, 0x74, 0xaa, 0x49]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public calculateFloatingValue_ = async (badMarkets: UInt256<TLargeInteger>, totalMarkets: UInt256<TLargeInteger>, targetDivisor: UInt256<TLargeInteger>, previousValue: UInt256<TLargeInteger>, defaultValue: UInt256<TLargeInteger>, floor: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5b, 0xaf, 0xec, 0xf5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_badMarkets",
            "type": "uint256"
        }, { "name": "_totalMarkets", "type": "uint256" }, {
            "name": "_targetDivisor",
            "type": "uint256"
        }, { "name": "_previousValue", "type": "uint256" }, {
            "name": "_defaultValue",
            "type": "uint256"
        }, { "name": "_floor", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newValue", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [badMarkets, totalMarkets, targetDivisor, previousValue, defaultValue, floor]);
        return <UInt256<TLargeInteger>>result._newValue
    };

    public getInitialReportMinValue_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5f, 0x72, 0x3b, 0x50]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getOpenInterestInAttoEth_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6a, 0x9d, 0x76, 0x29]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getDisputeWindow_ = async (disputeWindowId: UInt256<TLargeInteger>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6c, 0x23, 0xf7, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_disputeWindowId",
            "type": "uint256"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [disputeWindowId]);
        return <Address>result.result
    };

    public getRepMarketCapInAttoEth_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6d, 0x17, 0x43, 0xc4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getWinningChildUniverse_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6f, 0x70, 0xb9, 0xcb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getAuction_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x73, 0x27, 0xdf, 0x25]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public removeMarketFrom = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x77, 0xa3, 0xa0, 0xa2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'removeMarketFrom' })
    };

    public removeMarketFrom_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x77, 0xa3, 0xa0, 0xa2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getForkEndTime_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x77, 0xe7, 0x1e, 0xe5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getForkReputationGoal_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7c, 0x37, 0x7d, 0x74]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getDisputeWindowId_ = async (timestamp: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x89, 0xd5, 0xcf, 0xc6]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_timestamp", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [timestamp]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getOrCacheReportingFeeDivisor = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8f, 0x93, 0xbf, 0xfe]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getOrCacheReportingFeeDivisor' })
    };

    public getOrCacheReportingFeeDivisor_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8f, 0x93, 0xbf, 0xfe]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public isParentOf_ = async (shadyChild: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x17, 0x31, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_shadyChild", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [shadyChild]);
        return <boolean>result.result
    };

    public completeSets_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x99, 0x43, 0x6d, 0x68]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public updateForkValues = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9a, 0xb4, 0x48, 0xd9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'updateForkValues' })
    };

    public updateForkValues_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9a, 0xb4, 0x48, 0xd9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public isContainerForMarket_ = async (shadyMarket: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x7e, 0x1b, 0xf6]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_shadyMarket", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [shadyMarket]);
        return <boolean>result.result
    };

    public getParentUniverse_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa6, 0x3f, 0x13, 0x50]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getOrCreateCurrentDisputeWindow = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa8, 0x72, 0xb8, 0x6f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getOrCreateCurrentDisputeWindow' })
    };

    public getOrCreateCurrentDisputeWindow_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa8, 0x72, 0xb8, 0x6f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getDisputeWindowByTimestamp_ = async (timestamp: UInt256<TLargeInteger>, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x80, 0x24, 0xff]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_timestamp", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [timestamp]);
        return <Address>result.result
    };

    public disputeWindowFactory_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0xf4, 0x18, 0x5d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getOrCacheValidityBond = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xaf, 0x4c, 0xd4, 0x57]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getOrCacheValidityBond' })
    };

    public getOrCacheValidityBond_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xaf, 0x4c, 0xd4, 0x57]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getInitialReportStakeSize = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xaf, 0x6b, 0x36, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getInitialReportStakeSize' })
    };

    public getInitialReportStakeSize_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xaf, 0x6b, 0x36, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public createCategoricalMarket = async (endTime: UInt256<TLargeInteger>, feePerEthInWei: UInt256<TLargeInteger>, designatedReporterAddress: Address, outcomes: Array<Bytes32>, topic: Bytes32, description: string, extraInfo: string, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb2, 0x8b, 0xcc, 0x94]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_endTime",
            "type": "uint256"
        }, { "name": "_feePerEthInWei", "type": "uint256" }, {
            "name": "_designatedReporterAddress",
            "type": "address"
        }, { "name": "_outcomes", "type": "bytes32[]" }, {
            "name": "_topic",
            "type": "bytes32"
        }, { "name": "_description", "type": "string" }, { "name": "_extraInfo", "type": "string" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [endTime, feePerEthInWei, designatedReporterAddress, outcomes, topic, description, extraInfo], { transactionName: 'createCategoricalMarket' })
    };

    public createCategoricalMarket_ = async (endTime: UInt256<TLargeInteger>, feePerEthInWei: UInt256<TLargeInteger>, designatedReporterAddress: Address, outcomes: Array<Bytes32>, topic: Bytes32, description: string, extraInfo: string, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb2, 0x8b, 0xcc, 0x94]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_endTime",
            "type": "uint256"
        }, { "name": "_feePerEthInWei", "type": "uint256" }, {
            "name": "_designatedReporterAddress",
            "type": "address"
        }, { "name": "_outcomes", "type": "bytes32[]" }, {
            "name": "_topic",
            "type": "bytes32"
        }, { "name": "_description", "type": "string" }, { "name": "_extraInfo", "type": "string" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newMarket", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [endTime, feePerEthInWei, designatedReporterAddress, outcomes, topic, description, extraInfo]);
        return <Address>result._newMarket
    };

    public getOrCreateDisputeWindowBefore = async (disputeWindow: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb3, 0xd5, 0x06, 0x48]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_disputeWindow",
            "type": "address"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [disputeWindow], { transactionName: 'getOrCreateDisputeWindowBefore' })
    };

    public getOrCreateDisputeWindowBefore_ = async (disputeWindow: Address, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb3, 0xd5, 0x06, 0x48]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_disputeWindow",
            "type": "address"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [disputeWindow]);
        return <Address>result.result
    };

    public decrementOpenInterest = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb6, 0x24, 0x18, 0xa1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amount], { transactionName: 'decrementOpenInterest' })
    };

    public decrementOpenInterest_ = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb6, 0x24, 0x18, 0xa1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amount]);
        return <boolean>result.result
    };

    public getReputationToken_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb8, 0x09, 0x07, 0xf2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public isForking_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbe, 0xcb, 0x1f, 0x35]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getParentPayoutDistributionHash_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc3, 0x8c, 0x0f, 0xa7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public getForkingMarket_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xcb, 0x1d, 0x84, 0x18]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public incrementOpenInterest = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xce, 0x48, 0x3e, 0x88]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amount], { transactionName: 'incrementOpenInterest' })
    };

    public incrementOpenInterest_ = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xce, 0x48, 0x3e, 0x88]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amount]);
        return <boolean>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public redeemStake = async (reportingParticipants: Array<Address>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xde, 0x6d, 0xe7, 0xdf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_reportingParticipants",
            "type": "address[]"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [reportingParticipants], { transactionName: 'redeemStake' })
    };

    public redeemStake_ = async (reportingParticipants: Array<Address>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xde, 0x6d, 0xe7, 0xdf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_reportingParticipants",
            "type": "address[]"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [reportingParticipants]);
        return <boolean>result.result
    };

    public getOrCacheDesignatedReportStake = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe7, 0x96, 0x09, 0xe2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getOrCacheDesignatedReportStake' })
    };

    public getOrCacheDesignatedReportStake_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe7, 0x96, 0x09, 0xe2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getOrCacheMarketCreationCost = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xec, 0x86, 0xfd, 0xbd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getOrCacheMarketCreationCost' })
    };

    public getOrCacheMarketCreationCost_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xec, 0x86, 0xfd, 0xbd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getChildUniverse_ = async (parentPayoutDistributionHash: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xec, 0xeb, 0xa8, 0x76]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_parentPayoutDistributionHash",
            "type": "bytes32"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [parentPayoutDistributionHash]);
        return <Address>result.result
    };

    public getCurrentDisputeWindow_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf0, 0xb4, 0xb4, 0xdf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public updateTentativeWinningChildUniverse = async (parentPayoutDistributionHash: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf7, 0x09, 0x5d, 0x9d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_parentPayoutDistributionHash",
            "type": "bytes32"
        }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [parentPayoutDistributionHash], { transactionName: 'updateTentativeWinningChildUniverse' })
    };

    public updateTentativeWinningChildUniverse_ = async (parentPayoutDistributionHash: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf7, 0x09, 0x5d, 0x9d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_parentPayoutDistributionHash",
            "type": "bytes32"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [parentPayoutDistributionHash]);
        return <boolean>result.result
    };

    public isContainerForReportingParticipant_ = async (shadyReportingParticipant: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf7, 0x65, 0x14, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_shadyReportingParticipant",
            "type": "address"
        }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [shadyReportingParticipant]);
        return <boolean>result.result
    };

    public createScalarMarket = async (endTime: UInt256<TLargeInteger>, feePerEthInWei: UInt256<TLargeInteger>, designatedReporterAddress: Address, minPrice: Int256<TLargeInteger>, maxPrice: Int256<TLargeInteger>, numTicks: UInt256<TLargeInteger>, topic: Bytes32, description: string, extraInfo: string, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xb6, 0x51, 0x0c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_endTime",
            "type": "uint256"
        }, { "name": "_feePerEthInWei", "type": "uint256" }, {
            "name": "_designatedReporterAddress",
            "type": "address"
        }, { "name": "_minPrice", "type": "int256" }, { "name": "_maxPrice", "type": "int256" }, {
            "name": "_numTicks",
            "type": "uint256"
        }, { "name": "_topic", "type": "bytes32" }, {
            "name": "_description",
            "type": "string"
        }, { "name": "_extraInfo", "type": "string" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [endTime, feePerEthInWei, designatedReporterAddress, minPrice, maxPrice, numTicks, topic, description, extraInfo], { transactionName: 'createScalarMarket' })
    };

    public createScalarMarket_ = async (endTime: UInt256<TLargeInteger>, feePerEthInWei: UInt256<TLargeInteger>, designatedReporterAddress: Address, minPrice: Int256<TLargeInteger>, maxPrice: Int256<TLargeInteger>, numTicks: UInt256<TLargeInteger>, topic: Bytes32, description: string, extraInfo: string, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xb6, 0x51, 0x0c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_endTime",
            "type": "uint256"
        }, { "name": "_feePerEthInWei", "type": "uint256" }, {
            "name": "_designatedReporterAddress",
            "type": "address"
        }, { "name": "_minPrice", "type": "int256" }, { "name": "_maxPrice", "type": "int256" }, {
            "name": "_numTicks",
            "type": "uint256"
        }, { "name": "_topic", "type": "bytes32" }, {
            "name": "_description",
            "type": "string"
        }, { "name": "_extraInfo", "type": "string" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_newMarket", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [endTime, feePerEthInWei, designatedReporterAddress, minPrice, maxPrice, numTicks, topic, description, extraInfo]);
        return <Address>result._newMarket
    };

    public getDisputeThresholdForFork_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfb, 0x03, 0xea, 0xea]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public getOrCacheDesignatedReportNoShowBond = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfd, 0x1e, 0x5e, 0x7a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'getOrCacheDesignatedReportNoShowBond' })
    };

    public getOrCacheDesignatedReportNoShowBond_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfd, 0x1e, 0x5e, 0x7a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public addMarketTo = async (options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfe, 0xed, 0xa3, 0x67]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'addMarketTo' })
    };

    public addMarketTo_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfe, 0xed, 0xa3, 0x67]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
	}
}


export class CancelOrder<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public cancelOrders = async (orderIds: Array<Bytes32>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x21, 0xc7, 0x7c, 0x96]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderIds", "type": "bytes32[]" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [orderIds], { transactionName: 'cancelOrders' })
    };

    public cancelOrders_ = async (orderIds: Array<Bytes32>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x21, 0xc7, 0x7c, 0x96]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderIds", "type": "bytes32[]" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderIds]);
        return <boolean>result.result
    };

    public orders_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4f, 0xb7, 0x64, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public cancelOrder = async (orderId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x74, 0x89, 0xec, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [orderId], { transactionName: 'cancelOrder' })
    };

    public cancelOrder_ = async (orderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x74, 0x89, 0xec, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <boolean>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public initialize = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
	}
}


export class Cash<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public supply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x04, 0x7f, 0xc9, 0xaa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public defaultOperators_ = async (options?: {}): Promise<Array<Address>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xe4, 0x85, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address[]" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Array<Address>>result.result
    };

    public name_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xfd, 0xde, 0x03]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public approve = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, amount], { transactionName: 'approve' })
    };

    public approve_ = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, amount]);
        return <boolean>result.result
    };

    public totalSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x16, 0x0d, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public withdrawEtherTo = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1b, 0xaf, 0xfe, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount], { transactionName: 'withdrawEtherTo' })
    };

    public withdrawEtherTo_ = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1b, 0xaf, 0xfe, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount]);
        return <boolean>result.result
    };

    public transferFrom = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount], { transactionName: 'transferFrom' })
    };

    public transferFrom_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount]);
        return <boolean>result.result
    };

    public decimals_ = async (options?: {}): Promise<UInt8> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x31, 0x3c, 0xe5, 0x67]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint8" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt8>result.result
    };

    public withdrawEther = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3b, 0xed, 0x33, 0xce]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [amount], { transactionName: 'withdrawEther' })
    };

    public withdrawEther_ = async (amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3b, 0xed, 0x33, 0xce]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [amount]);
        return <boolean>result.result
    };

    public depositEtherFor = async (to: Address, options?: { attachedEth?: UInt256<TLargeInteger> }): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4f, 0xaa, 0x8a, 0x26]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_to", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to], { transactionName: 'depositEtherFor' }, options.attachedEth)
    };

    public depositEtherFor_ = async (to: Address, options?: { attachedEth?: UInt256<TLargeInteger> }): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4f, 0xaa, 0x8a, 0x26]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_to", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to], options.attachedEth);
        return <boolean>result.result
    };

    public granularity_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x55, 0x6f, 0x0d, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public ETERNAL_APPROVAL_VALUE_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x63, 0x4e, 0xaf, 0xf1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public decreaseApproval = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, subtractedValue], { transactionName: 'decreaseApproval' })
    };

    public decreaseApproval_ = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, subtractedValue]);
        return <boolean>result.result
    };

    public balanceOf_ = async (tokenHolder: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x70, 0xa0, 0x82, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [tokenHolder]);
        return <UInt256<TLargeInteger>>result.result
    };

    public sendNoHooks = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'sendNoHooks' })
    };

    public sendNoHooks_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public authorizeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'authorizeOperator' })
    };

    public authorizeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public symbol_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xd8, 0x9b, 0x41]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public depositEther = async (options?: { attachedEth?: UInt256<TLargeInteger> }): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x98, 0xea, 0x5f, 0xca]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'depositEther' }, options.attachedEth)
    };

    public depositEther_ = async (options?: { attachedEth?: UInt256<TLargeInteger> }): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x98, 0xea, 0x5f, 0xca]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [], options.attachedEth);
        return <boolean>result.result
    };

    public erc820Registry_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x2a, 0x14, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public transfer = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount], { transactionName: 'transfer' })
    };

    public transfer_ = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount]);
        return <boolean>result.result
    };

    public send = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'send' })
    };

    public send_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public initialize = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public increaseApproval = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, addedValue], { transactionName: 'increaseApproval' })
    };

    public increaseApproval_ = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, addedValue]);
        return <boolean>result.result
    };

    public isOperatorFor_ = async (operator: Address, tokenHolder: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0x5b, 0x63, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_operator",
            "type": "address"
        }, { "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator, tokenHolder]);
        return <boolean>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public operatorSend = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount, data, operatorData], { transactionName: 'operatorSend' })
    };

    public operatorSend_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount, data, operatorData]);
        return <boolean>result.result
    };

    public allowance_ = async (owner: Address, spender: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdd, 0x62, 0xed, 0x3e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_spender", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owner, spender]);
        return <UInt256<TLargeInteger>>result.result
    };

    public withdrawEtherToIfPossible = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xea, 0x1e, 0x74, 0xef]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount], { transactionName: 'withdrawEtherToIfPossible' })
    };

    public withdrawEtherToIfPossible_ = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xea, 0x1e, 0x74, 0xef]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount]);
        return <boolean>result.result
    };

    public revokeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'revokeOperator' })
    };

    public revokeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
	}
}


export class ClaimTradingProceeds<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public calculateCreatorFee_ = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0x06, 0x5c, 0xed]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, amount]);
        return <UInt256<TLargeInteger>>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public calculateReportingFee = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x81, 0x89, 0x44, 0x07]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [market, amount], { transactionName: 'calculateReportingFee' })
    };

    public calculateReportingFee_ = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x81, 0x89, 0x44, 0x07]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, amount]);
        return <UInt256<TLargeInteger>>result.result
    };

    public divideUpWinnings = async (market: Address, outcome: UInt256<TLargeInteger>, numberOfShares: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x66, 0xcd, 0xdf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }, { "name": "_numberOfShares", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [market, outcome, numberOfShares], { transactionName: 'divideUpWinnings' })
    };

    public divideUpWinnings_ = async (market: Address, outcome: UInt256<TLargeInteger>, numberOfShares: UInt256<TLargeInteger>, options?: {}): Promise<{ _proceeds: UInt256<TLargeInteger>, _shareHolderShare: UInt256<TLargeInteger>, _creatorShare: UInt256<TLargeInteger>, _reporterShare: UInt256<TLargeInteger> }> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x66, 0xcd, 0xdf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }, { "name": "_numberOfShares", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_proceeds",
            "type": "uint256"
        }, { "name": "_shareHolderShare", "type": "uint256" }, {
            "name": "_creatorShare",
            "type": "uint256"
        }, { "name": "_reporterShare", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, outcome, numberOfShares]);
        return <{ _proceeds: UInt256<TLargeInteger>, _shareHolderShare: UInt256<TLargeInteger>, _creatorShare: UInt256<TLargeInteger>, _reporterShare: UInt256<TLargeInteger> }>result
    };

    public claimTradingProceeds = async (market: Address, shareHolder: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb5, 0x37, 0x09, 0xaf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_shareHolder", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [market, shareHolder], { transactionName: 'claimTradingProceeds' })
    };

    public claimTradingProceeds_ = async (market: Address, shareHolder: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb5, 0x37, 0x09, 0xaf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_shareHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, shareHolder]);
        return <boolean>result.result
    };

    public initialize = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public calculateProceeds_ = async (market: Address, outcome: UInt256<TLargeInteger>, numberOfShares: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf2, 0xdc, 0x82, 0x66]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }, { "name": "_numberOfShares", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, outcome, numberOfShares]);
        return <UInt256<TLargeInteger>>result.result
	}
}


export class CompleteSets<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public publicBuyCompleteSetsWithCash = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x20, 0x54, 0x27, 0x9e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [market, amount], { transactionName: 'publicBuyCompleteSetsWithCash' })
    };

    public publicBuyCompleteSetsWithCash_ = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x20, 0x54, 0x27, 0x9e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, amount]);
        return <boolean>result.result
    };

    public sellCompleteSets = async (sender: Address, market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x2b, 0xb6, 0x6c, 0x48]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_sender",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [sender, market, amount], { transactionName: 'sellCompleteSets' })
    };

    public sellCompleteSets_ = async (sender: Address, market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<{ _creatorFee: UInt256<TLargeInteger>, _reportingFee: UInt256<TLargeInteger> }> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x2b, 0xb6, 0x6c, 0x48]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_sender",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_creatorFee",
            "type": "uint256"
        }, { "name": "_reportingFee", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [sender, market, amount]);
        return <{ _creatorFee: UInt256<TLargeInteger>, _reportingFee: UInt256<TLargeInteger> }>result
    };

    public fillOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5c, 0x1a, 0xd8, 0x44]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public publicSellCompleteSetsWithCash = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7d, 0x8e, 0xc2, 0xcf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [market, amount], { transactionName: 'publicSellCompleteSetsWithCash' })
    };

    public publicSellCompleteSetsWithCash_ = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7d, 0x8e, 0xc2, 0xcf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, amount]);
        return <boolean>result.result
    };

    public buyCompleteSets = async (sender: Address, market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xaa, 0x48, 0xdb, 0x20]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_sender",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [sender, market, amount], { transactionName: 'buyCompleteSets' })
    };

    public buyCompleteSets_ = async (sender: Address, market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xaa, 0x48, 0xdb, 0x20]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_sender",
            "type": "address"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [sender, market, amount]);
        return <boolean>result.result
    };

    public publicBuyCompleteSets = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xab, 0xb6, 0x0c, 0x80]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [market, amount], { transactionName: 'publicBuyCompleteSets' })
    };

    public publicBuyCompleteSets_ = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xab, 0xb6, 0x0c, 0x80]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, amount]);
        return <boolean>result.result
    };

    public publicSellCompleteSets = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xad, 0x16, 0x15, 0x8e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [market, amount], { transactionName: 'publicSellCompleteSets' })
    };

    public publicSellCompleteSets_ = async (market: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xad, 0x16, 0x15, 0x8e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, amount]);
        return <boolean>result.result
    };

    public initialize = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
	}
}


export class CreateOrder<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public trade_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1f, 0x0b, 0xa6, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public publicCreateOrder = async (type: UInt8, attoshares: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, market: Address, outcome: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, ignoreShares: boolean, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x59, 0xf9, 0xbf, 0x64]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_attoshares", "type": "uint256" }, { "name": "_price", "type": "uint256" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_ignoreShares", "type": "bool" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [type, attoshares, price, market, outcome, betterOrderId, worseOrderId, tradeGroupId, ignoreShares], { transactionName: 'publicCreateOrder' })
    };

    public publicCreateOrder_ = async (type: UInt8, attoshares: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, market: Address, outcome: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, ignoreShares: boolean, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x59, 0xf9, 0xbf, 0x64]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_attoshares", "type": "uint256" }, { "name": "_price", "type": "uint256" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_ignoreShares", "type": "bool" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, attoshares, price, market, outcome, betterOrderId, worseOrderId, tradeGroupId, ignoreShares]);
        return <Bytes32>result.result
    };

    public createOrder = async (creator: Address, type: UInt8, attoshares: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, market: Address, outcome: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, ignoreShares: boolean, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5a, 0x00, 0x5d, 0xbe]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_creator",
            "type": "address"
        }, { "name": "_type", "type": "uint8" }, { "name": "_attoshares", "type": "uint256" }, {
            "name": "_price",
            "type": "uint256"
        }, { "name": "_market", "type": "address" }, {
            "name": "_outcome",
            "type": "uint256"
        }, { "name": "_betterOrderId", "type": "bytes32" }, {
            "name": "_worseOrderId",
            "type": "bytes32"
        }, { "name": "_tradeGroupId", "type": "bytes32" }, { "name": "_ignoreShares", "type": "bool" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [creator, type, attoshares, price, market, outcome, betterOrderId, worseOrderId, tradeGroupId, ignoreShares], { transactionName: 'createOrder' })
    };

    public createOrder_ = async (creator: Address, type: UInt8, attoshares: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, market: Address, outcome: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, ignoreShares: boolean, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5a, 0x00, 0x5d, 0xbe]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_creator",
            "type": "address"
        }, { "name": "_type", "type": "uint8" }, { "name": "_attoshares", "type": "uint256" }, {
            "name": "_price",
            "type": "uint256"
        }, { "name": "_market", "type": "address" }, {
            "name": "_outcome",
            "type": "uint256"
        }, { "name": "_betterOrderId", "type": "bytes32" }, {
            "name": "_worseOrderId",
            "type": "bytes32"
        }, { "name": "_tradeGroupId", "type": "bytes32" }, { "name": "_ignoreShares", "type": "bool" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [creator, type, attoshares, price, market, outcome, betterOrderId, worseOrderId, tradeGroupId, ignoreShares]);
        return <Bytes32>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public initialize = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public publicCreateOrders = async (outcomes: Array<UInt256<TLargeInteger>>, types: Array<UInt8>, attoshareAmounts: Array<UInt256<TLargeInteger>>, prices: Array<UInt256<TLargeInteger>>, market: Address, ignoreShares: boolean, tradeGroupId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd5, 0x91, 0x50, 0xdf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_outcomes",
            "type": "uint256[]"
        }, { "name": "_types", "type": "uint8[]" }, {
            "name": "_attoshareAmounts",
            "type": "uint256[]"
        }, { "name": "_prices", "type": "uint256[]" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_ignoreShares", "type": "bool" }, { "name": "_tradeGroupId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [outcomes, types, attoshareAmounts, prices, market, ignoreShares, tradeGroupId], { transactionName: 'publicCreateOrders' })
    };

    public publicCreateOrders_ = async (outcomes: Array<UInt256<TLargeInteger>>, types: Array<UInt8>, attoshareAmounts: Array<UInt256<TLargeInteger>>, prices: Array<UInt256<TLargeInteger>>, market: Address, ignoreShares: boolean, tradeGroupId: Bytes32, options?: {}): Promise<Array<Bytes32>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd5, 0x91, 0x50, 0xdf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_outcomes",
            "type": "uint256[]"
        }, { "name": "_types", "type": "uint8[]" }, {
            "name": "_attoshareAmounts",
            "type": "uint256[]"
        }, { "name": "_prices", "type": "uint256[]" }, {
            "name": "_market",
            "type": "address"
        }, { "name": "_ignoreShares", "type": "bool" }, { "name": "_tradeGroupId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orders", "type": "bytes32[]" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [outcomes, types, attoshareAmounts, prices, market, ignoreShares, tradeGroupId]);
        return <Array<Bytes32>>result._orders
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
	}
}


export class FillOrder<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public trade_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1f, 0x0b, 0xa6, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public orders_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4f, 0xb7, 0x64, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public publicFillOrder = async (orderId: Bytes32, amountFillerWants: UInt256<TLargeInteger>, tradeGroupId: Bytes32, ignoreShares: boolean, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xac, 0x61, 0x2b, 0x0a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_amountFillerWants", "type": "uint256" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_ignoreShares", "type": "bool" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [orderId, amountFillerWants, tradeGroupId, ignoreShares], { transactionName: 'publicFillOrder' })
    };

    public publicFillOrder_ = async (orderId: Bytes32, amountFillerWants: UInt256<TLargeInteger>, tradeGroupId: Bytes32, ignoreShares: boolean, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xac, 0x61, 0x2b, 0x0a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_amountFillerWants", "type": "uint256" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_ignoreShares", "type": "bool" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId, amountFillerWants, tradeGroupId, ignoreShares]);
        return <UInt256<TLargeInteger>>result.result
    };

    public initialize = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public fillOrder = async (filler: Address, orderId: Bytes32, amountFillerWants: UInt256<TLargeInteger>, tradeGroupId: Bytes32, ignoreShares: boolean, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd3, 0xb6, 0x88, 0x78]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_filler",
            "type": "address"
        }, { "name": "_orderId", "type": "bytes32" }, {
            "name": "_amountFillerWants",
            "type": "uint256"
        }, { "name": "_tradeGroupId", "type": "bytes32" }, { "name": "_ignoreShares", "type": "bool" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [filler, orderId, amountFillerWants, tradeGroupId, ignoreShares], { transactionName: 'fillOrder' })
    };

    public fillOrder_ = async (filler: Address, orderId: Bytes32, amountFillerWants: UInt256<TLargeInteger>, tradeGroupId: Bytes32, ignoreShares: boolean, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd3, 0xb6, 0x88, 0x78]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_filler",
            "type": "address"
        }, { "name": "_orderId", "type": "bytes32" }, {
            "name": "_amountFillerWants",
            "type": "uint256"
        }, { "name": "_tradeGroupId", "type": "bytes32" }, { "name": "_ignoreShares", "type": "bool" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [filler, orderId, amountFillerWants, tradeGroupId, ignoreShares]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
	}
}


export class Orders<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public getAmount_ = async (orderId: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0e, 0x0a, 0x0d, 0x74]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt256<TLargeInteger>>result.result
    };

    public descendOrderList_ = async (type: UInt8, price: UInt256<TLargeInteger>, highestOrderId: Bytes32, options?: {}): Promise<{ _betterOrderId: Bytes32, _worseOrderId: Bytes32 }> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0e, 0x14, 0x24, 0xb5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_highestOrderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, highestOrderId]);
        return <{ _betterOrderId: Bytes32, _worseOrderId: Bytes32 }>result
    };

    public getOrderId_ = async (type: UInt8, market: Address, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, sender: Address, blockNumber: UInt256<TLargeInteger>, outcome: UInt256<TLargeInteger>, moneyEscrowed: UInt256<TLargeInteger>, sharesEscrowed: UInt256<TLargeInteger>, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x17, 0x27, 0x58, 0x3c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_price",
            "type": "uint256"
        }, { "name": "_sender", "type": "address" }, {
            "name": "_blockNumber",
            "type": "uint256"
        }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_moneyEscrowed",
            "type": "uint256"
        }, { "name": "_sharesEscrowed", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, market, amount, price, sender, blockNumber, outcome, moneyEscrowed, sharesEscrowed]);
        return <Bytes32>result.result
    };

    public assertIsNotBetterPrice_ = async (type: UInt8, price: UInt256<TLargeInteger>, betterOrderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x19, 0xe5, 0x4f, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_betterOrderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, betterOrderId]);
        return <boolean>result.result
    };

    public trade_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x1f, 0x0b, 0xa6, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public recordFillOrder = async (orderId: Bytes32, sharesFilled: UInt256<TLargeInteger>, tokensFilled: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x2e, 0xd5, 0xca, 0x29]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_sharesFilled", "type": "uint256" }, { "name": "_tokensFilled", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [orderId, sharesFilled, tokensFilled], { transactionName: 'recordFillOrder' })
    };

    public recordFillOrder_ = async (orderId: Bytes32, sharesFilled: UInt256<TLargeInteger>, tokensFilled: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x2e, 0xd5, 0xca, 0x29]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_orderId",
            "type": "bytes32"
        }, { "name": "_sharesFilled", "type": "uint256" }, { "name": "_tokensFilled", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId, sharesFilled, tokensFilled]);
        return <boolean>result.result
    };

    public setPrice = async (market: Address, outcome: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x30, 0x11, 0xe1, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }, { "name": "_price", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [market, outcome, price], { transactionName: 'setPrice' })
    };

    public setPrice_ = async (market: Address, outcome: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x30, 0x11, 0xe1, 0x6a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }, { "name": "_price", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, outcome, price]);
        return <boolean>result.result
    };

    public getPrice_ = async (orderId: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x31, 0xd9, 0x8b, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getTotalEscrowed_ = async (market: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x37, 0xec, 0x11, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_market", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market]);
        return <UInt256<TLargeInteger>>result.result
    };

    public findBoundingOrders = async (type: UInt8, price: UInt256<TLargeInteger>, bestOrderId: Bytes32, worstOrderId: Bytes32, betterOrderId: Bytes32, worseOrderId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3b, 0x01, 0xcf, 0x3c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_bestOrderId",
            "type": "bytes32"
        }, { "name": "_worstOrderId", "type": "bytes32" }, {
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [type, price, bestOrderId, worstOrderId, betterOrderId, worseOrderId], { transactionName: 'findBoundingOrders' })
    };

    public findBoundingOrders_ = async (type: UInt8, price: UInt256<TLargeInteger>, bestOrderId: Bytes32, worstOrderId: Bytes32, betterOrderId: Bytes32, worseOrderId: Bytes32, options?: {}): Promise<{ betterOrderId: Bytes32, worseOrderId: Bytes32 }> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3b, 0x01, 0xcf, 0x3c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_bestOrderId",
            "type": "bytes32"
        }, { "name": "_worstOrderId", "type": "bytes32" }, {
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "betterOrderId",
            "type": "bytes32"
        }, { "name": "worseOrderId", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, bestOrderId, worstOrderId, betterOrderId, worseOrderId]);
        return <{ betterOrderId: Bytes32, worseOrderId: Bytes32 }>result
    };

    public assertIsNotWorsePrice = async (type: UInt8, price: UInt256<TLargeInteger>, worseOrderId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x45, 0xc9, 0x2c, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_worseOrderId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [type, price, worseOrderId], { transactionName: 'assertIsNotWorsePrice' })
    };

    public assertIsNotWorsePrice_ = async (type: UInt8, price: UInt256<TLargeInteger>, worseOrderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x45, 0xc9, 0x2c, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_worseOrderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, worseOrderId]);
        return <boolean>result.result
    };

    public getOrderMoneyEscrowed_ = async (orderId: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4a, 0x1a, 0x34, 0x2b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt256<TLargeInteger>>result.result
    };

    public fillOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5c, 0x1a, 0xd8, 0x44]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public isBetterPrice_ = async (type: UInt8, price: UInt256<TLargeInteger>, orderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5c, 0xf1, 0x7b, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, orderId]);
        return <boolean>result.result
    };

    public getOutcome_ = async (orderId: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5d, 0x1a, 0x3b, 0x82]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt256<TLargeInteger>>result.result
    };

    public createOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x65, 0x12, 0xe6, 0xec]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public cancelOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6a, 0x81, 0x65, 0x48]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public saveOrder = async (type: UInt8, market: Address, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, sender: Address, outcome: UInt256<TLargeInteger>, moneyEscrowed: UInt256<TLargeInteger>, sharesEscrowed: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6b, 0xc2, 0x9e, 0xfa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_price",
            "type": "uint256"
        }, { "name": "_sender", "type": "address" }, {
            "name": "_outcome",
            "type": "uint256"
        }, { "name": "_moneyEscrowed", "type": "uint256" }, {
            "name": "_sharesEscrowed",
            "type": "uint256"
        }, { "name": "_betterOrderId", "type": "bytes32" }, {
            "name": "_worseOrderId",
            "type": "bytes32"
        }, { "name": "_tradeGroupId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [type, market, amount, price, sender, outcome, moneyEscrowed, sharesEscrowed, betterOrderId, worseOrderId, tradeGroupId], { transactionName: 'saveOrder' })
    };

    public saveOrder_ = async (type: UInt8, market: Address, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, sender: Address, outcome: UInt256<TLargeInteger>, moneyEscrowed: UInt256<TLargeInteger>, sharesEscrowed: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6b, 0xc2, 0x9e, 0xfa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_price",
            "type": "uint256"
        }, { "name": "_sender", "type": "address" }, {
            "name": "_outcome",
            "type": "uint256"
        }, { "name": "_moneyEscrowed", "type": "uint256" }, {
            "name": "_sharesEscrowed",
            "type": "uint256"
        }, { "name": "_betterOrderId", "type": "bytes32" }, {
            "name": "_worseOrderId",
            "type": "bytes32"
        }, { "name": "_tradeGroupId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, market, amount, price, sender, outcome, moneyEscrowed, sharesEscrowed, betterOrderId, worseOrderId, tradeGroupId]);
        return <Bytes32>result._orderId
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public getBestOrderId_ = async (type: UInt8, market: Address, outcome: UInt256<TLargeInteger>, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7b, 0x6e, 0xaa, 0x65]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, market, outcome]);
        return <Bytes32>result.result
    };

    public getLastOutcomePrice_ = async (market: Address, outcome: UInt256<TLargeInteger>, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x80, 0x4f, 0xb4, 0x10]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_market",
            "type": "address"
        }, { "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [market, outcome]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getWorseOrderId_ = async (orderId: Bytes32, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x89, 0x25, 0xf9, 0xe9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <Bytes32>result.result
    };

    public getWorstOrderId_ = async (type: UInt8, market: Address, outcome: UInt256<TLargeInteger>, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x8e, 0x12, 0xeb, 0xad]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, market, outcome]);
        return <Bytes32>result.result
    };

    public getBetterOrderId_ = async (orderId: Bytes32, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x94, 0xd2, 0x6c, 0xb5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <Bytes32>result.result
    };

    public getMarket_ = async (orderId: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc3, 0xc9, 0x5c, 0x7b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <Address>result.result
    };

    public initialize = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public getOrderType_ = async (orderId: Bytes32, options?: {}): Promise<UInt8> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xcf, 0x35, 0x73, 0x64]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint8" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt8>result.result
    };

    public isWorsePrice_ = async (type: UInt8, price: UInt256<TLargeInteger>, orderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0xb3, 0xd9, 0xfe]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, orderId]);
        return <boolean>result.result
    };

    public getOrderCreator_ = async (orderId: Bytes32, options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe7, 0xd8, 0x0c, 0x70]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <Address>result.result
    };

    public getOrderSharesEscrowed_ = async (orderId: Bytes32, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xeb, 0xea, 0xd0, 0x5f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public ascendOrderList_ = async (type: UInt8, price: UInt256<TLargeInteger>, lowestOrderId: Bytes32, options?: {}): Promise<{ _betterOrderId: Bytes32, _worseOrderId: Bytes32 }> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf8, 0x26, 0x6a, 0x7a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_type",
            "type": "uint8"
        }, { "name": "_price", "type": "uint256" }, { "name": "_lowestOrderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [type, price, lowestOrderId]);
        return <{ _betterOrderId: Bytes32, _worseOrderId: Bytes32 }>result
    };

    public removeOrder = async (orderId: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfd, 0xe9, 0x96, 0x68]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [orderId], { transactionName: 'removeOrder' })
    };

    public removeOrder_ = async (orderId: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfd, 0xe9, 0x96, 0x68]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_orderId", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [orderId]);
        return <boolean>result.result
	}
}


export class ShareToken<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public supply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x04, 0x7f, 0xc9, 0xaa]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public defaultOperators_ = async (options?: {}): Promise<Array<Address>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xe4, 0x85, 0x38]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address[]" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Array<Address>>result.result
    };

    public name_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x06, 0xfd, 0xde, 0x03]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public approve = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, amount], { transactionName: 'approve' })
    };

    public approve_ = async (spender: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x09, 0x5e, 0xa7, 0xb3]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, amount]);
        return <boolean>result.result
    };

    public createShares = async (owner: Address, fxpValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0f, 0x9e, 0x5b, 0xbd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_fxpValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [owner, fxpValue], { transactionName: 'createShares' })
    };

    public createShares_ = async (owner: Address, fxpValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x0f, 0x9e, 0x5b, 0xbd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_fxpValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owner, fxpValue]);
        return <boolean>result.result
    };

    public totalSupply_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x18, 0x16, 0x0d, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public transferFrom = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount], { transactionName: 'transferFrom' })
    };

    public transferFrom_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x23, 0xb8, 0x72, 0xdd]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount]);
        return <boolean>result.result
    };

    public decimals_ = async (options?: {}): Promise<UInt8> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x31, 0x3c, 0xe5, 0x67]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint8" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt8>result.result
    };

    public trustedFillOrderTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3d, 0x3c, 0x5c, 0x9f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedFillOrderTransfer' })
    };

    public trustedFillOrderTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x3d, 0x3c, 0x5c, 0x9f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public claimTradingProceeds_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x42, 0x61, 0x14, 0x3e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public granularity_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x55, 0x6f, 0x0d, 0xc7]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public fillOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5c, 0x1a, 0xd8, 0x44]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public ETERNAL_APPROVAL_VALUE_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x63, 0x4e, 0xaf, 0xf1]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public createOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x65, 0x12, 0xe6, 0xec]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public decreaseApproval = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, subtractedValue], { transactionName: 'decreaseApproval' })
    };

    public decreaseApproval_ = async (spender: Address, subtractedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x66, 0x18, 0x84, 0x63]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_subtractedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, subtractedValue]);
        return <boolean>result.result
    };

    public cancelOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x6a, 0x81, 0x65, 0x48]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public balanceOf_ = async (tokenHolder: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x70, 0xa0, 0x82, 0x31]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [tokenHolder]);
        return <UInt256<TLargeInteger>>result.result
    };

    public trustedOrderTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x76, 0x4c, 0x92, 0xf2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedOrderTransfer' })
    };

    public trustedOrderTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x76, 0x4c, 0x92, 0xf2]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public trustedCancelOrderTransfer = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7b, 0x30, 0x07, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [source, destination, attotokens], { transactionName: 'trustedCancelOrderTransfer' })
    };

    public trustedCancelOrderTransfer_ = async (source: Address, destination: Address, attotokens: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7b, 0x30, 0x07, 0x4d]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_source",
            "type": "address"
        }, { "name": "_destination", "type": "address" }, { "name": "_attotokens", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [source, destination, attotokens]);
        return <boolean>result.result
    };

    public getOutcome_ = async (options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7e, 0x7e, 0x4b, 0x47]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <UInt256<TLargeInteger>>result.result
    };

    public sendNoHooks = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'sendNoHooks' })
    };

    public sendNoHooks_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x82, 0x94, 0x29, 0x15]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public authorizeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'authorizeOperator' })
    };

    public authorizeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0x9b, 0x8c, 0x3f]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
    };

    public symbol_ = async (options?: {}): Promise<string> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x95, 0xd8, 0x9b, 0x41]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "string" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <string>result.result
    };

    public completeSets_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x99, 0x43, 0x6d, 0x68]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public erc820Registry_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x9f, 0x2a, 0x14, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public transfer = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount], { transactionName: 'transfer' })
    };

    public transfer_ = async (to: Address, amount: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa9, 0x05, 0x9c, 0xbb]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount]);
        return <boolean>result.result
    };

    public send = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [to, amount, data], { transactionName: 'send' })
    };

    public send_ = async (to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xb1, 0x9f, 0x42, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_to",
            "type": "address"
        }, { "name": "_amount", "type": "uint256" }, { "name": "_data", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [to, amount, data]);
        return <boolean>result.result
    };

    public initialize = async (augur: Address, market: Address, outcome: UInt256<TLargeInteger>, erc820RegistryAddress: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbe, 0x20, 0x30, 0x94]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_outcome",
            "type": "uint256"
        }, { "name": "_erc820RegistryAddress", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur, market, outcome, erc820RegistryAddress], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, market: Address, outcome: UInt256<TLargeInteger>, erc820RegistryAddress: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xbe, 0x20, 0x30, 0x94]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_augur",
            "type": "address"
        }, { "name": "_market", "type": "address" }, {
            "name": "_outcome",
            "type": "uint256"
        }, { "name": "_erc820RegistryAddress", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur, market, outcome, erc820RegistryAddress]);
        return <boolean>result.result
    };

    public destroyShares = async (owner: Address, fxpValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd3, 0x33, 0xd7, 0xcf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_fxpValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [owner, fxpValue], { transactionName: 'destroyShares' })
    };

    public destroyShares_ = async (owner: Address, fxpValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd3, 0x33, 0xd7, 0xcf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_fxpValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owner, fxpValue]);
        return <boolean>result.result
    };

    public increaseApproval = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [spender, addedValue], { transactionName: 'increaseApproval' })
    };

    public increaseApproval_ = async (spender: Address, addedValue: UInt256<TLargeInteger>, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd7, 0x3d, 0xd6, 0x23]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_spender",
            "type": "address"
        }, { "name": "_addedValue", "type": "uint256" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [spender, addedValue]);
        return <boolean>result.result
    };

    public isOperatorFor_ = async (operator: Address, tokenHolder: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xd9, 0x5b, 0x63, 0x71]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_operator",
            "type": "address"
        }, { "name": "_tokenHolder", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator, tokenHolder]);
        return <boolean>result.result
    };

    public getTypeName_ = async (options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0x0a, 0x08, 0x7c]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Bytes32>result.result
    };

    public operatorSend = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [from, to, amount, data, operatorData], { transactionName: 'operatorSend' })
    };

    public operatorSend_ = async (from: Address, to: Address, amount: UInt256<TLargeInteger>, data: Bytes32, operatorData: Bytes32, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdb, 0xbb, 0xdc, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_from",
            "type": "address"
        }, { "name": "_to", "type": "address" }, { "name": "_amount", "type": "uint256" }, {
            "name": "_data",
            "type": "bytes32"
        }, { "name": "_operatorData", "type": "bytes32" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [from, to, amount, data, operatorData]);
        return <boolean>result.result
    };

    public allowance_ = async (owner: Address, spender: Address, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xdd, 0x62, 0xed, 0x3e]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_owner",
            "type": "address"
        }, { "name": "_spender", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [owner, spender]);
        return <UInt256<TLargeInteger>>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public getMarket_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xf1, 0xbe, 0x16, 0x79]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public revokeOperator = async (operator: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [operator], { transactionName: 'revokeOperator' })
    };

    public revokeOperator_ = async (operator: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfa, 0xd8, 0xb3, 0x2a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_operator", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [operator]);
        return <boolean>result.result
	}
}


export class Trade<TLargeInteger> extends Contract<TLargeInteger> {
    public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

    public orders_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x4f, 0xb7, 0x64, 0xc9]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public fillOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x5c, 0x1a, 0xd8, 0x44]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public createOrder_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x65, 0x12, 0xe6, 0xec]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public augur_ = async (options?: {}): Promise<Address> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0x7a, 0x0d, 0x8f, 0x8a]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "address" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <Address>result.result
    };

    public publicFillBestOrder = async (direction: UInt8, market: Address, outcome: UInt256<TLargeInteger>, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, tradeGroupId: Bytes32, loopLimit: UInt256<TLargeInteger>, ignoreShares: boolean, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa1, 0x09, 0x3a, 0xc5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_direction",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_amount",
            "type": "uint256"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_loopLimit", "type": "uint256" }, { "name": "_ignoreShares", "type": "bool" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [direction, market, outcome, amount, price, tradeGroupId, loopLimit, ignoreShares], { transactionName: 'publicFillBestOrder' })
    };

    public publicFillBestOrder_ = async (direction: UInt8, market: Address, outcome: UInt256<TLargeInteger>, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, tradeGroupId: Bytes32, loopLimit: UInt256<TLargeInteger>, ignoreShares: boolean, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xa1, 0x09, 0x3a, 0xc5]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_direction",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_amount",
            "type": "uint256"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_loopLimit", "type": "uint256" }, { "name": "_ignoreShares", "type": "bool" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [direction, market, outcome, amount, price, tradeGroupId, loopLimit, ignoreShares]);
        return <UInt256<TLargeInteger>>result.result
    };

    public initialize = async (augur: Address, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [augur], { transactionName: 'initialize' })
    };

    public initialize_ = async (augur: Address, options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xc4, 0xd6, 0x6d, 0xe8]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{ "name": "_augur", "type": "address" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [augur]);
        return <boolean>result.result
    };

    public publicTrade = async (direction: UInt8, market: Address, outcome: UInt256<TLargeInteger>, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, loopLimit: UInt256<TLargeInteger>, ignoreShares: boolean, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe4, 0x44, 0xd9, 0xcf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_direction",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_amount",
            "type": "uint256"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_loopLimit", "type": "uint256" }, { "name": "_ignoreShares", "type": "bool" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [direction, market, outcome, amount, price, betterOrderId, worseOrderId, tradeGroupId, loopLimit, ignoreShares], { transactionName: 'publicTrade' })
    };

    public publicTrade_ = async (direction: UInt8, market: Address, outcome: UInt256<TLargeInteger>, amount: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, loopLimit: UInt256<TLargeInteger>, ignoreShares: boolean, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xe4, 0x44, 0xd9, 0xcf]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_direction",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_amount",
            "type": "uint256"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_loopLimit", "type": "uint256" }, { "name": "_ignoreShares", "type": "bool" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [direction, market, outcome, amount, price, betterOrderId, worseOrderId, tradeGroupId, loopLimit, ignoreShares]);
        return <Bytes32>result.result
    };

    public getInitialized_ = async (options?: {}): Promise<boolean> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xee, 0x89, 0xda, 0xb4]));
        const inputParameterDescriptions: Array<ParameterDescription> = [];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bool" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, []);
        return <boolean>result.result
    };

    public publicTradeWithTotalCost = async (direction: UInt8, market: Address, outcome: UInt256<TLargeInteger>, totalCost: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, loopLimit: UInt256<TLargeInteger>, ignoreShares: boolean, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xef, 0x65, 0xf1, 0x0b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_direction",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_totalCost",
            "type": "uint256"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_loopLimit", "type": "uint256" }, { "name": "_ignoreShares", "type": "bool" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [direction, market, outcome, totalCost, price, betterOrderId, worseOrderId, tradeGroupId, loopLimit, ignoreShares], { transactionName: 'publicTradeWithTotalCost' })
    };

    public publicTradeWithTotalCost_ = async (direction: UInt8, market: Address, outcome: UInt256<TLargeInteger>, totalCost: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, betterOrderId: Bytes32, worseOrderId: Bytes32, tradeGroupId: Bytes32, loopLimit: UInt256<TLargeInteger>, ignoreShares: boolean, options?: {}): Promise<Bytes32> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xef, 0x65, 0xf1, 0x0b]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_direction",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_totalCost",
            "type": "uint256"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_betterOrderId",
            "type": "bytes32"
        }, { "name": "_worseOrderId", "type": "bytes32" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_loopLimit", "type": "uint256" }, { "name": "_ignoreShares", "type": "bool" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "bytes32" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [direction, market, outcome, totalCost, price, betterOrderId, worseOrderId, tradeGroupId, loopLimit, ignoreShares]);
        return <Bytes32>result.result
    };

    public publicFillBestOrderWithTotalCost = async (direction: UInt8, market: Address, outcome: UInt256<TLargeInteger>, totalCost: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, tradeGroupId: Bytes32, loopLimit: UInt256<TLargeInteger>, ignoreShares: boolean, options?: {}): Promise<Array<Event<TLargeInteger>>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfc, 0x46, 0x98, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_direction",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_totalCost",
            "type": "uint256"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_loopLimit", "type": "uint256" }, { "name": "_ignoreShares", "type": "bool" }];
        return await this.remoteCall(signatureHash, inputParameterDescriptions, [direction, market, outcome, totalCost, price, tradeGroupId, loopLimit, ignoreShares], { transactionName: 'publicFillBestOrderWithTotalCost' })
    };

    public publicFillBestOrderWithTotalCost_ = async (direction: UInt8, market: Address, outcome: UInt256<TLargeInteger>, totalCost: UInt256<TLargeInteger>, price: UInt256<TLargeInteger>, tradeGroupId: Bytes32, loopLimit: UInt256<TLargeInteger>, ignoreShares: boolean, options?: {}): Promise<UInt256<TLargeInteger>> => {
        options = options || {};
        const signatureHash = new SignatureHash().from(Uint8Array.from([0xfc, 0x46, 0x98, 0x84]));
        const inputParameterDescriptions: Array<ParameterDescription> = [{
            "name": "_direction",
            "type": "uint8"
        }, { "name": "_market", "type": "address" }, { "name": "_outcome", "type": "uint256" }, {
            "name": "_totalCost",
            "type": "uint256"
        }, { "name": "_price", "type": "uint256" }, {
            "name": "_tradeGroupId",
            "type": "bytes32"
        }, { "name": "_loopLimit", "type": "uint256" }, { "name": "_ignoreShares", "type": "bool" }];
        const outputParameterDescriptions: Array<ParameterDescription> = [{ "name": "", "type": "uint256" }];
        const result = await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [direction, market, outcome, totalCost, price, tradeGroupId, loopLimit, ignoreShares]);
        return <UInt256<TLargeInteger>>result.result
    }
}


// helpers

// TextEncoder/TextDecoder is in a different location in Browser vs NodeJS
const isBrowser = new Function("try {return this===window;}catch(e){ return false;}");

interface ITextEncoder {
    encode(input: string): Uint8Array
}

interface ITextDecoder {
    decode(input: Uint8Array): string
}
// browser
declare const TextEncoder: any, TextDecoder: any;
// nodejs
let util: { TextEncoder: any, TextDecoder: any } = isBrowser() ? {} : require("util");

function createTextEncoder(): ITextEncoder {
    return isBrowser() ? new TextEncoder() : new util.TextEncoder();
}

function createTextDecoder(): ITextDecoder {
    return isBrowser() ? new TextDecoder() : new util.TextDecoder();
}

function encodeSmallInteger(x: number): Bytes32 {
    const negative = x < 0;
    const stringified = ((negative ? 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff' : '0000000000000000000000000000000000000000000000000000000000000000') + (negative ? (2 ** 32 - (x * -1)) : x).toString(16)).slice(-64);

    const result = new Bytes32();
    for (let i = 0; i < stringified.length; i += 2) {
        result[i / 2] = Number.parseInt(stringified[i] + stringified[i + 1], 16)
    }
    return result
}

function decodeSmallInteger(data: Bytes32): number {
    const negative = data[0] >= 0b10000000;
    const bytes = new Bytes4().from(data.subarray(28, 32));
    const parsed = parseInt(bytes.to0xString());
    return negative ? parsed >> 0 : parsed
}

function padLeftTo32Bytes(input: Uint8Array): Bytes {
    const result = new Bytes(input.length + 32 - input.length % 32);
    result.set(input, result.length - input.length);
    return result
}

function padRightTo32Bytes(input: Uint8Array): Bytes {
    const result = new Bytes(input.length + 32 - input.length % 32);
    result.set(input, 0);
    return result
}

function concatenateBytes(source: Array<Uint8Array>): Bytes {
    const size = source.reduce((previous, current) => previous += current.byteLength, 0);
    const result = new Bytes(size);
    let offset = 0;
    for (let array of source) {
        result.set(array, offset);
        offset += array.byteLength
    }
    return result
}

function numberToBytes32(source: number): Bytes32 {
    if (!Number.isSafeInteger(source)) throw new Error(`Cannot construct a Bytes32 from an unsafe integer like ${source}.`);
    return encodeSmallInteger(source)
}

function padAndLengthPrefix(source: Uint8Array): Bytes {
    const length = source.length;
    const padded = padRightTo32Bytes(source);
    return concatenateBytes([numberToBytes32(length), padded])
}

function encodeDynamicData(encodedData: Array<{ isDynamic: boolean, bytes: Uint8Array }>): Bytes {
    let staticBytesSize = 0;
    for (let encodedParameter of encodedData) {
        if (encodedParameter.isDynamic) staticBytesSize += 32;
        else staticBytesSize += encodedParameter.bytes.length
    }
    const staticBytes: Array<Uint8Array> = [];
    const dynamicBytes: Array<Uint8Array> = [];
    for (let encodedParameter of encodedData) {
        if (encodedParameter.isDynamic) {
            const dynamicBytesAppendedSoFar = dynamicBytes.reduce((total, bytes) => total += bytes.length, 0);
            staticBytes.push(numberToBytes32(staticBytesSize + dynamicBytesAppendedSoFar));
            dynamicBytes.push(encodedParameter.bytes)
        } else {
            staticBytes.push(encodedParameter.bytes)
        }
    }
    return concatenateBytes([...staticBytes, ...dynamicBytes])
}

function anyIsDynamic(descriptions: Array<ParameterDescription>): boolean {
    for (let description of descriptions) {
        if (isDynamic(description)) return true
    }
    return false
}

function isDynamic(description: ParameterDescription): boolean {
    if (description.type === 'string') return true;
    if (description.type === 'bytes') return true;
    if (description.type.endsWith('[]')) return true;
    const fixedArrayMatcher = /^(.*)\[(\d+)\]$/.exec(description.type);
    if (fixedArrayMatcher !== null && isDynamic(Object.assign({}, description, { type: fixedArrayMatcher[1] }))) return true;
    if (description.type === 'tuple' && anyIsDynamic(description.components || [])) return true;
    return false
}
