pragma solidity 0.5.15;
pragma experimental ABIEncoderV2;

import 'ROOT/libraries/ContractExists.sol';
import "ROOT/trading/wrappedShareToken/WrappedShareToken.sol";
import 'ROOT/para/interfaces/IParaShareToken.sol';
import "ROOT/libraries/CloneFactory2.sol";


/**
 * @dev This is a factory that creates Wrappers around ERC1155 shareTokens generated by Augur
 * @author yashnaman
 * as shares on outcomes of a markets.
 * For every outcome there will be one wrapper.
 */
contract WrappedShareTokenFactory is CloneFactory2 {
    using ContractExists for address;

    // contract cloned for each wrapped token
    WrappedShareToken public tokenTemplate;
    // share token => tokenId => symbol => wrapper
    mapping(address => mapping(uint256 => mapping(string => address))) public wrappers;

    event WrappedShareTokenCreated(IParaShareToken indexed shareToken, uint256 indexed tokenId, address tokenAddress, string symbol);

    constructor (WrappedShareToken _tokenTemplate) public {
        tokenTemplate = _tokenTemplate;
    }

    /**@dev creates new ERC20 wrappers for a outcome of a market
     *@param _paraShareToken address of shareToken associated with a augur universe
     *@param _tokenId token id associated with a outcome of a market
     *@param _symbol symbol for the ERC20 wrapper
     */
    function getOrCreateWrappedShareToken(
        IParaShareToken _shareToken,
        uint256 _tokenId,
        string memory _symbol
    ) public returns (WrappedShareToken) {
        address _wrapper = wrappers[address(_shareToken)][_tokenId][_symbol];
        if (_wrapper != address(0)) {
            return WrappedShareToken(_wrapper);
        } else {
            _wrapper = createClone2(address(tokenTemplate), salt(_shareToken, _tokenId, _symbol));
            wrappers[address(_shareToken)][_tokenId][_symbol] = _wrapper;
        }

        WrappedShareToken _wrappedShareToken = WrappedShareToken(_wrapper);
        _wrappedShareToken.initialize(
            _shareToken,
            _tokenId,
            _symbol
        );

        emit WrappedShareTokenCreated(_shareToken, _tokenId, _wrapper, _symbol);
        return _wrappedShareToken;
    }

    /**@dev creates new ERC20 wrappers for multiple tokenIds*/
    function getOrCreateWrappedShareTokens(
        IParaShareToken _shareToken,
        uint256[] memory _tokenIds,
        string[] memory _symbols
    ) public returns (WrappedShareToken[] memory _wrappedShareTokens){
        require(_tokenIds.length == _symbols.length, "Each token must have one symbol");
        _wrappedShareTokens = new WrappedShareToken[](_tokenIds.length);
        for (uint256 _i = 0; _i < _tokenIds.length; _i++) {
            _wrappedShareTokens[_i] = getOrCreateWrappedShareToken(_shareToken, _tokenIds[_i], _symbols[_i]);
        }
    }

    /**@dev A function that wraps ERC1155s shareToken into ERC20s
     * Requirements:
     * -  msg.sender has setApprovalForAll to this contract
     * @param _tokenId token id associated with a outcome of a market
     * @param _symbol symbol used for ERC20 for these shares
     * @param _account account the newly minted ERC20s will go to
     * @param _amount  amount of tokens to be wrapped
     */
    function wrapShares(
        IParaShareToken _shareToken,
        uint256 _tokenId,
        string memory _symbol,
        address _account,
        uint256 _amount
    ) public {
        WrappedShareToken _wrappedShareToken = getOrCreateWrappedShareToken(_shareToken, _tokenId, _symbol);
        _shareToken.unsafeTransferFrom(
            msg.sender,
            address(_wrappedShareToken),
            _tokenId,
            _amount
        );

        _wrappedShareToken.trustedWrapShares(_account, _amount);
    }

    /**@dev A function that burns ERC20s and gives back ERC1155s
     * Requirements:
     * - msg.sender has more than _amount of ERC20 tokens associated with _tokenId.
     * - if the market has finalized then it is  advised that you call claim() on WrappedShareToken
     * contract associated with the winning outcome
     * @param _tokenId token id associated with a outcome of a market
     * @param _symbol The humab readable representation of the token
     * @param _amount amount of tokens to be unwrapped
     */
    function unwrapShares(IParaShareToken _shareToken, uint256 _tokenId, string memory _symbol, uint256 _amount) public {
        WrappedShareToken wrappedShareToken = WrappedShareToken(calculateShareTokenAddress(_shareToken, _tokenId, _symbol));
        wrappedShareToken.unwrapShares(msg.sender, msg.sender, _amount);
    }

    function unwrapAllShares(IParaShareToken _shareToken, uint256 _tokenId, string memory _symbol) public {
        WrappedShareToken wrappedShareToken = WrappedShareToken(calculateShareTokenAddress(_shareToken, _tokenId, _symbol));
        wrappedShareToken.unwrapShares(msg.sender, msg.sender, wrappedShareToken.balanceOf(msg.sender));
    }

    /**@dev wraps multiple tokens */
    function wrapMultipleShares(
        IParaShareToken _shareToken,
        uint256[] memory _tokenIds,
        string[] memory _symbols,
        address _account,
        uint256[] memory _amounts
    ) public {
        for (uint256 i = 0; i < _tokenIds.length; i++) {
            wrapShares(_shareToken, _tokenIds[i], _symbols[i], _account, _amounts[i]);
        }
    }

    /**@dev unwraps multiple tokens */
    function unwrapMultipleShares(
        IParaShareToken _shareToken,
        uint256[] memory _tokenIds,
        string[] memory _symbols,
        uint256[] memory _amounts
    ) public {
        for (uint256 i = 0; i < _tokenIds.length; i++) {
            unwrapShares(_shareToken, _tokenIds[i], _symbols[i], _amounts[i]);
        }
    }

    /**
     * @notice Buy some amount of complete sets for a market
     * @param _market The market to purchase complete sets in
     * @param _amount The number of complete sets to purchase
     * @return Bool True
     */
    function publicBuyCompleteSets(IMarket _market, IParaShareToken _shareToken, string[] calldata _symbols, uint256 _amount) external returns (bool) {
        if(!_shareToken.isMarketInitialized(_market)) {
            _shareToken.initializeMarket(_market);
        }
        require(_market.getNumberOfOutcomes() == _symbols.length, "Must pass in one symbol name for each outcome");

        _shareToken.cash().approve(_shareToken.augur(), _amount * _market.getNumTicks());
        _shareToken.cash().transferFrom(msg.sender, address(this), _amount * _market.getNumTicks());
        _shareToken.publicBuyCompleteSets(_market, _amount);

        for (uint256 _i = 0; _i < _symbols.length; _i++) {
            uint256 _tokenId = _shareToken.getTokenId(_market, _i);
            WrappedShareToken _wrappedShareToken = getOrCreateWrappedShareToken(_shareToken, _tokenId, _symbols[_i]);
            _shareToken.unsafeTransferFrom(
                address(this),
                address(_wrappedShareToken),
                _tokenId,
                _amount
            );
            _wrappedShareToken.trustedWrapShares(msg.sender, _amount);
        }

        return true;
    }

    /**
     * @notice Sell complete sets for the underlying collateral
     * @param _market The market for which to sell complete sets
     * @param _symbols The token symbols for which you are selling, e.g yOutcome, nOutcome, iOutcome
     * @param _amount the number of complete sets to sell
     */
    function publicSellCompleteSets(IParaShareToken _shareToken, IMarket _market, string[] calldata _symbols, uint256 _amount) external returns (uint256 _creatorFee, uint256 _reportingFee) {
        require(_shareToken.isMarketInitialized(_market));
        require(_market.getNumberOfOutcomes() == _symbols.length, "Must pass in one symbol name for each outcome");

        for (uint256 _i = 0; _i < _symbols.length; _i++) {
            uint256 _tokenId = TokenId.getTokenId(_market, _i);
            WrappedShareToken _wrappedShareToken = WrappedShareToken(getOrCreateWrappedShareToken(_shareToken, _tokenId, _symbols[_i]));
            _wrappedShareToken.unwrapShares(msg.sender, address(this), _amount);
        }

        return _shareToken.sellCompleteSets(_market, address(this), msg.sender, _amount, bytes32(0));
    }

    /**@notice get the address for a particular WrappedShareToken
     *@param _shareToken ParaShareToken address for the collateral being used
     *@param _tokenId token id associated with a outcome of a market
     *@param _name a descriptive name mentioning market and outcome
     *@param _symbol symbol for the ERC20 wrapper
     *@param decimals decimals for the ERC20 wrapper
     */

    function calculateShareTokenAddress(IParaShareToken _shareToken, uint256 _tokenId, string memory _symbol) public view returns (address) {
        return clone2Address(address(tokenTemplate), salt(_shareToken, _tokenId, _symbol), address(this));
    }

    function salt(IParaShareToken _shareToken, uint256 _tokenId, string memory _symbol) private pure returns (uint256) {
        return uint256(keccak256(abi.encodePacked(_shareToken, _tokenId, _symbol)));
    }
 }
