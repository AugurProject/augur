pragma solidity 0.5.15;

import "ROOT/libraries/token/ERC1155Receiver.sol";
import "ROOT/libraries/token/ERC20.sol";
import 'ROOT/para/interfaces/IParaShareToken.sol';
import 'ROOT/libraries/TokenId.sol';
import 'ROOT/libraries/Initializable.sol';
import 'ROOT/libraries/Ownable.sol';

/**
 * @dev This is an Wrapper around ERC1155 shareTokens generated by Augur
 * @author justinbarry, pgebheim based on work by
 * For every outcome there will be one wrapper.
 * The approch here is simple. It gets ERC1155 token and mints ERC20.
 * It burns ERC20s and gives back the ERC11555s.
 * AugurFoundry passed in the constructor has special permission to mint and burn.
 */
contract WrappedShareToken is ERC20, Initializable, Ownable, ERC1155Receiver {
    IERC20 public cash;
    IParaShareToken public shareToken;
    string public symbol;
    uint256 public tokenId;
    uint256 public precisionMultiplier;

    /**
     * @dev sets values for
     * transaction without giving individual approvals
     * @param _shareToken address of shareToken for which this wrapper is for
     * @param _tokenId id of market outcome this wrapper is for
     * @param _symbol symbol
     */
    function initialize(IParaShareToken _shareToken, uint256 _tokenId, string calldata _symbol) external beforeInitialized {
        endInitialization();
        tokenId = _tokenId;
        shareToken = _shareToken;
        cash = _shareToken.cash();
        symbol = _symbol;
        uint256 _decimals = cash.decimals();
        require(_decimals <= 18, "Cannot support cash with >18 decimals");
        precisionMultiplier = 10**(18 - _decimals);
        owner = msg.sender;
    }

    /**@dev A function that gets ERC1155s and mints ERC20s
     * Requirements: User must have called setApprovalForAll for this contract
     *
     * @param _recipient account the newly minted ERC20s will go to
     * @param _amountIn amount of tokens to be wrapped
     */
    function wrapShares(address _recipient, uint256 _amountIn) public {
        shareToken.unsafeTransferFrom(
            msg.sender,
            address(this),
            tokenId,
            _amountIn
        );
        _mint(_recipient, _amountIn.mul(precisionMultiplier));
    }

    /** @dev Used by the WrappedShareTokenFactory to account for shares it has transferred
      * @param _recipient The account to which the newly minted ERC20s will go.
      * @param _amountIn The amount of tokens which have been wrapped
      */
    function trustedWrapShares(address _recipient, uint256 _amountIn) external onlyOwner {
        _mint(_recipient, _amountIn.mul(precisionMultiplier));
    }

    /** @notice A function that burns ERC20s and gives back ERC1155s
     * @param _holder account the newly minted ERC20s will go to
     * @param _amountIn amount of tokens to be unwrapped.
     */
    function unwrapShares(address _holder, address _recipient, uint256 _amountIn) public {
        if (msg.sender == _holder || msg.sender == owner) {
            _burn(_holder, _amountIn); // burn!!
        } else {
            _burnFrom(_holder, _amountIn); // burn and deduct approval from caller allowance
        }

        shareToken.unsafeTransferFrom(
            address(this),
            _recipient,
            tokenId,
            _amountIn.div(precisionMultiplier)
        );
    }

    /**
     * @dev Claims proceeds for the the total balance and sends portion to the shareholder
     * Caller must be approved to spend the shares out of the `_shareHolder` account
     * @param _shareHolder account for which DAI is being claimed
     */
    function claimTradingProceeds(address _shareHolder) public {
        /**@notice checks if the proceeds were claimed before. If not then claims the proceeds */
        if (shareToken.balanceOf(address(this), tokenId) != 0) {
            shareToken.claimTradingProceeds(
                shareToken.getMarket(tokenId),
                address(this),
                ""
            );
        }
        uint256 cashBalance = cash.balanceOf(address(this));
        /**@notice If this is a winning outcome then give the user thier share of DAI */
        if (cashBalance == 0) return;

        uint256 _shareHolderShare = (cashBalance.mul(balanceOf(_shareHolder))).div(
            totalSupply
        );

        if (msg.sender == _shareHolder) {
            _burn(_shareHolder, balanceOf(_shareHolder));
        } else {
            _burnFrom(_shareHolder, balanceOf(_shareHolder));
        }

        require(cash.transfer(_shareHolder, _shareHolderShare));
    }

    /**
     *  @dev Handles the receipt of a single ERC1155 token type. This function is
     *  called at the end of a `safeTransferFrom` after the balance has been updated.
     *  To accept the transfer, this must return
     *  `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
     *  (i.e. 0xf23a6e61, or its own function selector).
     *  @param operator The address which initiated the transfer (i.e. msg.sender)
     *  @param from The address which previously owned the token
     *  @param id The ID of the token being transferred
     *  @param value The amount of tokens being transferred
     *  @param data Additional data with no specified format
     *  @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
    */
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4) {
        /**@notice To make sure that no other tokenId other than what this ERC20 is a wrapper for is sent here*/
        require(id == tokenId, "Not acceptable");
        return (
            bytes4(
                keccak256(
                    "onERC1155Received(address,address,uint256,uint256,bytes)"
                )
            )
        );
    }

    /**
        @dev Handles the receipt of a multiple ERC1155 token types. This function
        is called at the end of a `safeBatchTransferFrom` after the balances have
        been updated. To accept the transfer(s), this must return
        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
        (i.e. 0xbc197c81, or its own function selector).
        @param operator The address which initiated the batch transfer (i.e. msg.sender)
        @param from The address which previously owned the token
        @param ids An array containing ids of each token being transferred (order and length must match values array)
        @param values An array containing amounts of each token being transferred (order and length must match ids array)
        @param data Additional data with no specified format
        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
    */
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4) {
        /**@notice This is not allowed. Just transfer one predefined id here */
        return "";
    }

    function onTokenTransfer(address _from, address _to, uint256 _value) internal {}
    function onTransferOwnership(address, address) internal {}

    /**
     * return The market associated with this WrappedShareToken
     */
    function getMarket() external view returns(IMarket) {
        (address _market, ) = TokenId.unpackTokenId(tokenId);
        return IMarket(_market);
    }

    /**
     * return The outcome associated with this WrappedShareToken
     */
    function getOutcome() external view returns(uint256) {
        (, uint256 _outcome) = TokenId.unpackTokenId(tokenId);
        return _outcome;
    }
}
